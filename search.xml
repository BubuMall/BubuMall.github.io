<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭建属于自己的科学上网方式</title>
      <link href="/2023/03/22/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/03/22/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://v2rayssr.com/teach-vless.html">https://v2rayssr.com/teach-vless.html</a></p><h2 id="买域名"><a href="#买域名" class="headerlink" title="买域名"></a>买域名</h2><p>参考域名网站：<a href="https://www.namesilo.com/cart">https://www.namesilo.com/cart</a></p><ol><li><p>注册账户</p><p><img src="F:\hexo\blog\source_posts\sw1.png"></p></li><li><p>购买，便宜域名只需要1.88刀</p></li><li></li></ol><h2 id="购买-VPS"><a href="#购买-VPS" class="headerlink" title="购买 VPS"></a>购买 VPS</h2><p><a href="https://www.vpsgo.com/">VPS GO - 便宜VPS，VPS推荐，美国主机，香港服务器，VPS教程</a></p><p>我选了这个</p><p><a href="https://my.racknerd.com/cart.php?a=confproduct&i=0&language=chinese">RackNerd LLC</a></p><p><img src="/../img/sw3.png"></p><p>购买成功配置SSH(<strong>我买的这个会发邮件告诉你ip和密码</strong>)</p><p><img src="/../img/sw4.png"></p><p>绑定DNS并且ping 域名</p><p><img src="/../img/sw5.png"></p><p>打开控制台</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 你的域名</span><br></pre></td></tr></table></figure><p>ping成功之后我们接着配置vps服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update -y          # Debian/Ubuntu 命令</span><br><span class="line">apt install -y curl socat    #Debian/Ubuntu 命令</span><br><span class="line">bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) #X-ui面板安装</span><br></pre></td></tr></table></figure><p><em>感觉有点慢</em></p><p>配置Qv2Ray</p><p><img src="/../img/sw6.png"></p><p>大概如上图这样，填写自己的域名，<strong>请求头</strong>填自己的域名。</p><p>教程里的所谓拯救垃圾VPS看来无用！！</p><div class="note warning simple"><p>如果 显示缺少核心文件</p></div><p>要下载4.4.5的V2raycore,然后解压到Qv2Ray同文件夹下</p><div class="note info flat"><p>建议还是弄其他的代理</p><p>比如Clash</p></div><p>PS: 不知道是我买的服务器问题还是什么，花了半天时间都没调好速度，最快也才1M多速率。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day30</title>
      <link href="/2023/03/21/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day30/"/>
      <url>/2023/03/21/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day30/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="JS-为什么存在数字精度丢失的问题，如何解决？"><a href="#JS-为什么存在数字精度丢失的问题，如何解决？" class="headerlink" title="JS 为什么存在数字精度丢失的问题，如何解决？"></a>JS 为什么存在数字精度丢失的问题，如何解决？</h2><p>JavaScript 存在数字精度丢失的问题是因为它使用的是基于 IEEE-754 标准的双精度浮点数格式，即使用 64 位来存储数字，其中只有 53 位用于存储有效数字。这意味着当数字的位数超过 53 位时， JavaScript 将不得不丢失一些精度。</p><p>解决这个问题的方法通常有：</p><ol><li>使用 JavaScript 的内置 BigInt 类型，它可以表示任意长度的整数。BigInt 类型是在 ECMAScript 2020 标准中引入的，因此可能不受所有浏览器的支持。</li><li>使用第三方库，如 big.js、decimal.js 等。这些库使用不同的算法来处理数值，可以避免丢失精度问题。</li><li>将数值转化为字符串进行处理，可以使用一些库来进行数值的精确计算。</li><li>避免使用小数运算，可以将小数转化为整数进行运算，再将结果转化为小数。</li></ol><p>例如，可以使用 <code>toFixed()</code> 方法将浮点数转化为字符串，并指定小数位数来避免精度丢失：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy codelet a = 0.1;</span><br><span class="line">let b = 0.2;</span><br><span class="line">let c = a + b;</span><br><span class="line">console.log(c.toFixed(1)); // 输出 0.3</span><br></pre></td></tr></table></figure><p>总之，由于 JavaScript 使用的是双精度浮点数格式，因此在进行数值处理时，应该注意避免超出精度的数字运算，或者使用正确的方法来处理精度丢失的问题。</p><h2 id="什么是前端跨平台？你用过哪些跨平台框架？"><a href="#什么是前端跨平台？你用过哪些跨平台框架？" class="headerlink" title="什么是前端跨平台？你用过哪些跨平台框架？"></a>什么是前端跨平台？你用过哪些跨平台框架？</h2><p>前端跨平台通常指的是使用一种代码语言或框架开发应用，然后在多个不同的操作系统或设备上运行应用的能力。这样可以避免为每个平台分别开发应用程序的麻烦，减少了开发时间和成本，提高了开发效率。</p><p>常见的前端跨平台框架包括：</p><ol><li>React Native：用于构建iOS和Android应用程序的开源框架，基于React构建。</li><li>Flutter：一个由Google开发的开源框架，可用于快速构建高性能、美观的Android和iOS应用程序。</li><li>Electron：一个使用Web技术（HTML、CSS和JavaScript）构建跨平台桌面应用程序的开源框架。</li><li>Ionic：一个基于HTML、CSS和JavaScript的开源框架，用于构建跨平台移动应用程序。</li><li>Weex：阿里巴巴推出的用于构建Android和iOS应用程序的框架，使用Vue构建。</li><li>Uniapp是一款基于Vue.js的跨平台开发框架，它可以用于构建iOS、Android、Web、以及各种小程序（如微信小程序、支付宝小程序等）等应用程序。</li></ol><p>我之前使用过React Native和Electron框架。其中React Native用于开发一个婚礼管理App，Electron用于构建一个简单的桌面应用程序。这些跨平台框架都提供了良好的跨平台兼容性和可移植性，使得开发人员可以将更多的精力放在业务逻辑的开发上，而不用担心跨平台的问题。</p><h2 id="什么是-Javascript-的事件流？有哪些事件流模型？"><a href="#什么是-Javascript-的事件流？有哪些事件流模型？" class="headerlink" title="什么是 Javascript 的事件流？有哪些事件流模型？"></a>什么是 Javascript 的事件流？有哪些事件流模型？</h2><p>JavaScript 的事件流（Event Flow）指的是浏览器中处理事件时所采用的机制和流程。当用户和 DOM 元素交互时，浏览器会按照一定的规则决定事件从哪个元素开始，经过哪些元素，最终到达目标元素，并触发相应的事件。</p><p>JavaScript 的事件流有三种模型：</p><ol><li>事件冒泡（Bubbling）：事件从目标元素开始向上冒泡，逐步传递到父元素，直到根元素。可以使用 <code>stopPropagation()</code> 方法停止事件冒泡。</li><li>事件捕获（Capturing）：事件从根元素开始向下捕获，逐步传递到子元素，直到目标元素。不同于事件冒泡的是，事件捕获需要在父元素阶段处理该事件，再传递到目标元素。可以使用 <code>addEventListener()</code> 方法设置监听器，第三个参数为 <code>true</code> 时即表示使用事件捕获。</li><li>DOM0 级事件处理程序：也称为“传统事件模型”，是一种将事件处理函数直接绑定到 DOM 元素上的方式。这种方式只支持事件冒泡，并且会覆盖同一元素上已有的事件处理函数。</li></ol><p>事件流模型的使用取决于事件需要处理的元素层级和业务需求。默认情况下，<code>addEventListener()</code> 方法使用事件冒泡模型，而且通常情况下使用事件冒泡模型更为通用，只有在特定需求下才需要使用事件捕获模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day29</title>
      <link href="/2023/03/20/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day29/"/>
      <url>/2023/03/20/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day29/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="怎么调试-Node-js-程序？"><a href="#怎么调试-Node-js-程序？" class="headerlink" title="怎么调试 Node.js 程序？"></a>怎么调试 Node.js 程序？</h2><p>调试 Node.js 程序有多种方法，以下是一些常见的调试技巧和工具：</p><p>使用 console.log()：在代码中添加 console.log() 语句，输出变量值、函数执行情况等，以便了解程序运行状态。这是最基本的调试手段，适用于简单的问题排查。</p><p>使用内置调试器：Node.js 提供了一个内置的命令行调试器。要使用它，只需在启动脚本时在命令行中添加 inspect 或 inspect-brk 标志，例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">inspect</span> app.js</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">--inspect-brk</span> app.js</span><br></pre></td></tr></table></figure><p>这将启动一个调试会话。你可以在代码中添加 debugger; 语句，作为断点。调试器将在遇到断点时暂停执行。</p><p>使用 Chrome DevTools：你可以使用 Chrome DevTools 来调试 Node.js 程序。首先，使用 inspect 或 inspect-brk 标志启动 Node.js 应用，然后打开 Chrome 浏览器，输入 chrome:&#x2F;&#x2F;inspect，在 “Devices” 下找到你的 Node.js 应用，并点击 “inspect”。这将打开一个 DevTools 实例，你可以像调试浏览器中的 JavaScript 代码一样调试 Node.js 代码。</p><p>使用 Visual Studio Code：Visual Studio Code 是一个流行的开源代码编辑器，内置了对 Node.js 的调试支持。要在 VSCode 中调试 Node.js 应用，需要创建一个名为 .vscode&#x2F;launch.json 的配置文件，配置调试参数。以下是一个简单的配置示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Launch Program&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;<span class="variable">$&#123;workspaceFolder&#125;</span>/app.js&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，按下 F5 或点击左侧 “Run and Debug” 选项卡上的 “Run” 按钮开始调试。你可以在代码中添加断点、查看变量值、使用控制台等。</p><p>使用其他 IDE 和编辑器：许多其他 IDE 和代码编辑器也提供了 Node.js 调试支持，如 WebStorm、Atom 等。具体操作方法因工具而异，请参考相应工具的文档。</p><p>选择合适的调试工具和方法可以帮助你更高效地找到和解决 Node.js 程序中的问题。</p><h2 id="你用过哪些包管理工具？它们各有什么特点？"><a href="#你用过哪些包管理工具？它们各有什么特点？" class="headerlink" title="你用过哪些包管理工具？它们各有什么特点？"></a>你用过哪些包管理工具？它们各有什么特点？</h2><p>我用过以下包管理工具：</p><ol><li>pip：Python的包管理工具，可以轻松地安装、升级和卸载Python包。它是Python社区中最常用的包管理工具之一，能够从PyPI（Python Package Index）中自动下载、安装和管理依赖。</li><li>npm：JavaScript的包管理工具，可以轻松地安装、升级和卸载JavaScript包。它是Node.js社区中最常用的包管理工具之一，可以从npm registry中下载、安装和管理依赖。</li><li>yarn：也是JavaScript的包管理工具，由Facebook开发。它具有与npm相同的功能，但有一些额外的特性，例如离线模式、并行安装、缓存等等。</li><li>Homebrew：macOS上的包管理工具，可以方便地安装、升级和卸载开源软件。它是基于Ruby语言的，可以从Homebrew的官方仓库中下载、安装和管理软件。</li><li>apt-get：Linux上的包管理工具，可以方便地安装、升级和卸载软件。它是Debian和Ubuntu Linux系统中最常用的包管理工具之一，可以从系统的软件仓库中下载、安装和管理软件。</li></ol><p>这些包管理工具都有各自的特点，比如支持的平台、安装速度、安全性等等。选择合适的包管理工具需要考虑到自己的使用场景和需求。</p><h2 id="SPA（单页应用）首屏加载速度慢怎么解决？"><a href="#SPA（单页应用）首屏加载速度慢怎么解决？" class="headerlink" title="SPA（单页应用）首屏加载速度慢怎么解决？"></a>SPA（单页应用）首屏加载速度慢怎么解决？</h2><p>单页应用（SPA）由于其特点，在首屏加载时，可能会出现加载速度慢的问题。为了解决这个问题，可以采用以下策略和技巧：</p><ol><li>代码拆分（Code Splitting）：将大型 JavaScript 文件拆分成更小的文件，按需加载。这可以通过使用动态导入（<code>import()</code> 语法）和 Webpack 等打包工具实现。代码拆分可以确保仅加载当前页面所需的代码，从而减少首屏加载时间。</li><li>懒加载（Lazy Loading）：只在需要时加载某些资源，如图片、视频和其他媒体内容。懒加载可以通过 JavaScript 代码实现，或使用新的 <code>loading=&quot;lazy&quot;</code> 属性（适用于部分现代浏览器）。</li><li>缓存策略：利用浏览器缓存来存储静态资源，如 CSS、JavaScript、图片等。可以通过设置 HTTP 缓存头来实现，如 <code>Cache-Control</code>、<code>ETag</code> 等。合理的缓存策略可以减少重复请求，提高首屏加载速度。</li><li>优化 JavaScript、CSS 和 HTML：压缩、混淆和缩小 JavaScript 和 CSS 文件，移除不必要的空格、注释和代码。对 HTML 文件进行类似的处理。可以使用诸如 UglifyJS、Terser、CSSNano 等工具进行优化。</li><li>使用 CDN（内容分发网络）：将静态资源部署到 CDN 上，可以使用户从最近的服务器获取资源，从而加速首屏加载速度。</li><li>服务端渲染（SSR）或预渲染（Prerendering）：通过在服务器端渲染初始 HTML，加快首次渲染速度。预渲染可以在构建阶段生成静态 HTML 文件，从而避免客户端在首次加载时执行过多的 JavaScript 代码。</li><li>优化网络请求：减少不必要的网络请求，合并多个请求（如使用 CSS Sprites 或 HTTP&#x2F;2 多路复用），以及优先加载关键资源。</li><li>优先加载关键路径（Critical Path）：确保首屏渲染所需的关键 CSS 和 JavaScript 代码优先加载。可以将关键 CSS 内联到 HTML 中，以避免额外的请求。</li><li>使用性能分析工具：利用诸如 Lighthouse、WebPageTest 和 Chrome DevTools 等工具分析应用性能，找出瓶颈并进行优化。</li></ol><p>通过采用以上策略，可以有效地提高 SPA 首屏加载速度，提升用户体验。这些方法需要针对具体的项目进行调整和实施，从而达到最佳效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day28</title>
      <link href="/2023/03/19/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day28/"/>
      <url>/2023/03/19/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day28/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="Node-js-有哪些全局对象？它们分别有什么作用？"><a href="#Node-js-有哪些全局对象？它们分别有什么作用？" class="headerlink" title="Node.js 有哪些全局对象？它们分别有什么作用？"></a>Node.js 有哪些全局对象？它们分别有什么作用？</h2><p>Node.js 中有一些全局对象，它们可以在任何模块中直接访问，无需进行导入。以下是一些常见的全局对象及其作用：</p><ol><li><code>global</code>：它是 Node.js 的全局命名空间，类似于浏览器环境中的 <code>window</code> 对象。在 <code>global</code> 对象上定义的属性和方法可以在任何地方访问。然而，在实际开发中，应避免在 <code>global</code> 对象上添加属性，以防止全局命名空间污染。</li><li><code>process</code>：它是一个全局对象，提供了关于当前 Node.js 进程的信息和对其进行控制的方法。<code>process</code> 对象包含诸如环境变量、命令行参数、内存使用情况、当前工作目录等属性和方法。</li><li><code>console</code>：它是一个全局对象，提供了用于输出信息和调试的方法，如 <code>console.log()</code>、<code>console.error()</code>、<code>console.warn()</code> 等。</li><li><code>setTimeout</code> 和 <code>clearTimeout</code>：这两个方法用于设置和清除定时器。<code>setTimeout</code> 方法用于在指定的毫秒数后执行一个回调函数，<code>clearTimeout</code> 方法用于取消一个先前通过 <code>setTimeout</code> 设置的定时器。</li><li><code>setInterval</code> 和 <code>clearInterval</code>：这两个方法用于设置和清除周期性定时器。<code>setInterval</code> 方法用于每隔指定的毫秒数执行一个回调函数，<code>clearInterval</code> 方法用于取消一个先前通过 <code>setInterval</code> 设置的定时器。</li><li><code>setImmediate</code> 和 <code>clearImmediate</code>：这两个方法用于在当前事件循环结束时执行一个回调函数。<code>setImmediate</code> 方法会将回调函数添加到事件循环的队列末尾，以便在当前事件循环的所有 I&#x2F;O 事件和定时器事件处理完毕后执行。<code>clearImmediate</code> 方法用于取消一个先前通过 <code>setImmediate</code> 设置的回调函数。</li><li><code>Buffer</code>：它是一个全局的构造函数，用于处理二进制数据，如文件 I&#x2F;O、网络 I&#x2F;O 等。<code>Buffer</code> 提供了一系列方法来创建和操作字节缓冲区。</li><li><code>require</code> 和 <code>module</code>：<code>require</code> 是一个全局函数，用于导入其他模块。<code>module</code> 是一个全局对象，表示当前模块。每个 Node.js 文件都是一个模块，模块可以导出函数、对象或值，以便其他模块使用。</li></ol><p>注意，虽然这些对象在全局范围内可用，但它们并非严格意义上的全局变量。在 Node.js 模块中，它们是模块作用域内的变量，这意味着在一个模块中定义的变量不会自动成为全局变量。</p><h2 id="简述-TCP-x2F-IP-网络模型，分为几层？每层的职责和作用是什么？"><a href="#简述-TCP-x2F-IP-网络模型，分为几层？每层的职责和作用是什么？" class="headerlink" title="简述 TCP&#x2F;IP 网络模型，分为几层？每层的职责和作用是什么？"></a>简述 TCP&#x2F;IP 网络模型，分为几层？每层的职责和作用是什么？</h2><p>TCP&#x2F;IP 网络模型（也称为互联网协议套件）是一种用于描述网络通信的概念模型。它分为四层，每层都有特定的职责和作用，它们分别是：</p><ol><li><strong>应用层</strong>（Application Layer）：应用层负责处理与应用程序的通信和数据传输。它包括各种应用层协议，例如 HTTP、HTTPS、FTP、SMTP、IMAP、POP3、DNS 等。这些协议定义了客户端和服务器之间如何互相发送和接收数据。应用层的主要职责是为应用程序提供用户接口、数据传输以及数据封装和解封装。</li><li><strong>传输层</strong>（Transport Layer）：传输层主要负责在网络中进行端到端的可靠数据传输。它提供了两种主要的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。TCP 提供了可靠、面向连接的数据传输，它可以确保数据在传输过程中不会丢失、重复或乱序。UDP 提供了不可靠、无连接的数据传输，它不能保证数据的传输质量，但传输速度更快，适用于实时通信等场景。</li><li><strong>网络层</strong>（Internet Layer）：网络层负责在不同网络之间进行数据包的路由和传输。它使用 IP（互联网协议）进行寻址和路由，将数据包从源主机传输到目的主机。网络层的主要职责包括：IP 地址分配、路由选择、分片和重组以及错误检测和处理。除了 IP 协议，网络层还包括其他协议，如 ICMP（互联网控制消息协议）和 IGMP（互联网组管理协议）。</li><li><strong>链路层</strong>（Link Layer）：链路层（又称网络接口层或数据链路层）负责在同一网络中进行数据帧的发送和接收。链路层的协议因网络硬件而异，如 Ethernet、Wi-Fi、PPP 等。链路层的主要职责包括：物理寻址、数据帧封装和解封装、差错检测、流量控制以及链路管理。</li></ol><p>总的来说，TCP&#x2F;IP 网络模型将网络通信划分为四个层次，每层都有自己的职责和功能。这种分层模型有助于降低网络系统的复杂性，便于设计、实现和维护网络协议和设备</p><h2 id="git-stash-命令有什么作用？什么时候适合用它？"><a href="#git-stash-命令有什么作用？什么时候适合用它？" class="headerlink" title="git stash 命令有什么作用？什么时候适合用它？"></a>git stash 命令有什么作用？什么时候适合用它？</h2><p><code>git stash</code> 命令用于<strong>临时保存当前工作区的修改</strong>，以便你可以在干净的工作区上执行其他操作，如切换分支、拉取更新等。当你完成其他操作后，可以使用 <code>git stash apply</code> 或 <code>git stash pop</code> 将之前保存的修改重新应用到工作区。</p><p><code>git stash</code> 在以下场景中非常有用：</p><ol><li>当你正在进行一项尚未完成的任务，但需要切换到其他分支处理紧急问题或更新时。你可以使用 <code>git stash</code> 临时保存当前修改，然后切换分支并处理其他任务。完成后，切换回原来的分支，并使用 <code>git stash apply</code> 或 <code>git stash pop</code> 恢复之前的修改，继续完成未完成的任务。</li><li>当你需要拉取远程仓库的更新，但当前工作区有未提交的修改时。使用 <code>git stash</code> 保存当前修改，拉取远程更新，然后使用 <code>git stash apply</code> 或 <code>git stash pop</code> 恢复修改。</li></ol><p>以下是一些常用的 <code>git stash</code> 子命令：</p><ul><li><code>git stash save [message]</code>：将当前工作区的修改保存到一个新的存储，并可以添加一个可选的描述信息。</li><li><code>git stash list</code>：列出所有的存储。</li><li><code>git stash apply [stash_name]</code>：将指定的存储应用到当前工作区，不删除存储。如果未指定存储名，则默认应用最近的存储。</li><li><code>git stash pop [stash_name]</code>：将指定的存储应用到当前工作区，并从存储列表中删除。如果未指定存储名，则默认应用并删除最近的存储。</li><li><code>git stash drop [stash_name]</code>：删除指定的存储。如果未指定存储名，则默认删除最近的存储。</li><li><code>git stash branch &lt;branch_name&gt; [stash_name]</code>：基于指定存储创建一个新分支，并将存储应用到新分支。如果未指定存储名，则默认使用最近的存储。</li><li><code>git stash clear</code>：删除所有的存储。</li></ul><p>总之，<code>git stash</code> 是一个非常有用的命令，用于临时保存工作区的修改，以便在干净的工作区上执行其他操作。在处理紧急任务、更新代码或切换分支时，<code>git stash</code> 都可以帮助你轻松管理工作区的状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day27</title>
      <link href="/2023/03/18/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day27/"/>
      <url>/2023/03/18/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day27/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="JS-会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？"><a href="#JS-会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？" class="headerlink" title="JS 会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？"></a>JS 会出现内存泄漏问题么？在哪些情况下可能会出现内存泄漏？</h2><p>JavaScript 也会出现<strong>内存泄漏问题</strong>。内存泄漏是指一些<strong>被分配的内存空间</strong>，因为某些原因而无法被<strong>垃圾回收机制</strong>回收，导致占用内存空间无法被释放，最终会导致程序崩溃。</p><p>在 JavaScript 中，内存泄漏通常出现在以下情况：</p><ol><li><strong>意外的全局变量</strong>：如果一个变量没有被垃圾回收，那么它的作用域会被认为是全局的，这样就会造成意外的全局变量，导致内存泄漏。</li><li><strong>定时器没有被清除</strong>：如果在页面关闭前，某个定时器没有被清除，它所引用的对象就不会被垃圾回收，从而导致内存泄漏。</li><li><strong>闭包</strong>：如果一个闭包中引用了外部变量，而这个闭包被其他代码引用，那么它所引用的外部变量就不会被垃圾回收，从而导致内存泄漏。</li><li><strong>DOM 引用</strong>：如果在页面上有大量的 DOM 元素，而这些元素被 JavaScript 代码所引用，但是却没有被正确地释放，就会导致内存泄漏。</li><li><strong>循环引用</strong>：如果两个或多个对象之间形成了循环引用，即相互引用对方，那么它们都不会被垃圾回收，从而导致内存泄漏。</li></ol><p>为了避免 JavaScript 中的内存泄漏问题，可以采取以下措施：</p><ol><li><strong>避免意外的全局变量</strong>，可以使用 “use strict” 模式，或者在函数中使用 var、let 或 const 声明变量。</li><li>在使用<strong>定时器</strong>时，一定要记得及时清除定时器。</li><li>尽量避免使用<strong>闭包</strong>，如果必须使用闭包，要注意不要引用外部变量或者及时清除闭包。</li><li>在操作 DOM 元素时，要<strong>及时释放引用</strong>，避免 DOM 引用导致内存泄漏。</li><li><strong>避免循环引用</strong>，可以在对象不再使用时，手动断开对象之间的引用关系。</li></ol><h2 id="HTTP-缓存有哪些实现方式？什么是协商缓存和强制缓存？"><a href="#HTTP-缓存有哪些实现方式？什么是协商缓存和强制缓存？" class="headerlink" title="HTTP 缓存有哪些实现方式？什么是协商缓存和强制缓存？"></a>HTTP 缓存有哪些实现方式？什么是协商缓存和强制缓存？</h2><p><strong>HTTP 缓存</strong>可以通过以下几种方式进行实现：</p><ol><li><strong>浏览器缓存</strong>：浏览器可以将最近请求过的资源保存到本地，下次请求时可以直接从本地读取，从而提高访问速度。</li><li><strong>代理缓存</strong>：代理服务器可以缓存响应，减少对原始服务器的请求次数，从而加快响应速度。</li><li><strong>网关缓存</strong>：网关可以缓存来自多个原始服务器的响应，然后将响应发送到客户端，从而提高性能。</li></ol><p>HTTP 缓存可以分为<strong>协商缓存</strong>和<strong>强制缓存</strong>两种类型。</p><p>强制缓存是指浏览器在请求资源时，不会发送任何请求头，直接从本地缓存中读取资源，从而提高响应速度。常见的实现方式包括：</p><ol><li>Expires 头部：指定资源过期的时间，如果在过期时间之前再次请求该资源，浏览器将直接从缓存中读取资源。</li><li>Cache-Control 头部：可以指定资源的缓存策略，包括 public、private、no-cache 等，控制浏览器的缓存行为。</li></ol><p><strong>协商缓存</strong>是指浏览器在请求资源时，会发送一些<strong>请求头</strong>到服务器，<strong>询问服务器资源是否已经发生改变</strong>。如果资源未发生改变，服务器将返回 <strong>304 状态码</strong>，告诉浏览器可以从缓存中读取资源，从而减少了网络带宽的使用。常见的实现方式包括：</p><ol><li><strong>Last-Modified &#x2F; If-Modified-Since 头部</strong>：浏览器在请求资源时，会将资源最后修改时间（Last-Modified）发送到服务器，服务器检查资源是否发生变化，如果没有发生变化，返回 304 状态码，否则返回新的资源。</li><li><strong>ETag &#x2F; If-None-Match 头部</strong>：服务器可以给每个资源分配一个唯一的标识符（ETag），浏览器在请求资源时，将该标识符发送到服务器，服务器检查资源是否发生变化，如果没有发生变化，返回 304 状态码，否则返回新的资源。</li></ol><p>需要注意的是，<strong>协商缓存</strong>虽然可以<strong>减少网络带宽的使用</strong>，但是需要服务器进行资源比较，因此会<strong>增加服务器的负载</strong>。</p><h2 id="怎么进行站点内的图片性能优化？"><a href="#怎么进行站点内的图片性能优化？" class="headerlink" title="怎么进行站点内的图片性能优化？"></a>怎么进行站点内的图片性能优化？</h2><p>站点内的图片性能优化可以从以下几个方面入手：</p><ol><li><strong>图片压缩</strong>：通过压缩图片的大小和质量，可以减少图片的加载时间。可以使用图片压缩工具（如 TinyPNG、JPEGmini 等）来压缩图片。</li><li><strong>图片格式优化</strong>：选择正确的图片格式可以减少图片的大小。常见的图片格式有 JPEG、PNG 和 GIF，可以根据图片的特点和用途选择合适的格式。</li><li><strong>延迟加载</strong>：对于页面中的长列表或懒加载场景，可以延迟加载图片，减少页面加载时间。可以使用工具（如 lazysizes、Lozad.js 等）来实现图片的延迟加载。</li><li><strong>图片预加载</strong>：在用户访问页面之前，可以预加载一些重要的图片，从而提高用户体验。可以使用工具（如 PreloadJS、image-preload 等）来实现图片的预加载。</li><li><strong>响应式图片</strong>：对于不同大小的屏幕，可以使用不同大小的图片来提高用户体验。可以使用 HTML 标签的 srcset 和 sizes 属性来实现响应式图片。</li><li><strong>CDN 加速</strong>：使用 CDN 可以加速图片的加载速度，缩短图片的响应时间。可以选择静态文件托管服务商（如七牛云、阿里云等）来实现 CDN 加速。</li><li><strong>图片懒加载</strong>：对于网页中需要加载大量图片的场景，可以使用图片懒加载技术，即当页面滚动到某个区域时再加载该区域内的图片，从而减少页面加载时间和网络带宽的消耗。可以使用工具（如 lazyload、intersection-observer 等）来实现图片懒加载。</li></ol><p>需要注意的是，以上优化策略都是针对特定场景和需求进行优化的，需要根据实际情况选择合适的优化策略。同时，在进行图片优化时，需要保证图片质量和用户体验，并注意不要过度压缩图片，影响用户体验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day26</title>
      <link href="/2023/03/18/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day26/"/>
      <url>/2023/03/18/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day26/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="什么是-Node-js-的事件循环机制？它是怎么实现的？"><a href="#什么是-Node-js-的事件循环机制？它是怎么实现的？" class="headerlink" title="什么是 Node.js 的事件循环机制？它是怎么实现的？"></a>什么是 Node.js 的事件循环机制？它是怎么实现的？</h2><p>Node.js 的事件循环（Event Loop）机制是 Node.js 中实现异步非阻塞I&#x2F;O的核心。事件循环允许 Node.js 可以在单个线程中处理高并发的请求，提高了程序的性能和响应能力。</p><p>事件循环是 Node.js 的运行机制，负责调度和处理各种事件（如I&#x2F;O操作、定时器、网络请求等）。以下是事件循环的主要实现流程：</p><ol><li>Node.js 在启动时会初始化事件循环。</li><li>执行输入的脚本，可能会注册各种事件（如I&#x2F;O操作、定时器等）。</li><li>事件循环开始运行，进入不同的阶段（Phases），如Timers、I&#x2F;O callbacks、Idle&#x2F;Prepare、Poll、Check和Close callbacks。每个阶段负责处理特定类型的事件。</li><li>当事件队列中的事件被处理完毕，事件循环会检查是否还有待处理的事件或回调。如果没有，事件循环结束，程序退出；否则，事件循环继续运行，处理新的事件。</li></ol><p>Node.js 的事件循环机制是基于 libuv 库实现的。libuv 是一个跨平台的异步I&#x2F;O库，提供了事件循环、线程池等功能。Node.js 使用 libuv 来实现事件循环，处理各种异步操作，如文件I&#x2F;O、网络请求、定时器等。</p><p>值得注意的是，Node.js 的事件循环与浏览器的事件循环有一定的区别。虽然它们的核心概念相似，但在实现细节和运行环境上有所不同。在使用 Node.js 时，需要理解其事件循环的特点，以便更好地编写异步代码。</p><h2 id="DNS-预解析是什么？怎么实现？"><a href="#DNS-预解析是什么？怎么实现？" class="headerlink" title="DNS 预解析是什么？怎么实现？"></a>DNS 预解析是什么？怎么实现？</h2><p>DNS 预解析（DNS Prefetching）是一种网络性能优化技术，用于提前解析用户可能访问的域名，以减少实际请求时的DNS解析时间。通过预解析，浏览器可以在用户实际访问一个链接之前就已经获取到对应的IP地址，从而降低网络延迟，加快页面加载速度。</p><p>DNS 预解析主要有两种实现方式：</p><p>自动预解析：现代浏览器通常会自动进行DNS预解析。浏览器会根据用户的浏览历史和页面内容分析可能需要预解析的域名，然后在后台进行DNS解析。这种方式无需开发者进行任何操作，浏览器会自动进行预解析。</p><p>手动预解析：开发者可以通过在HTML文档中添加标签来手动指定需要进行预解析的域名。这种方式可以让开发者更精确地控制哪些域名需要进行预解析。示例如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;link rel<span class="operator">=</span><span class="string">&quot;dns-prefetch&quot;</span> href<span class="operator">=</span><span class="string">&quot;//example.com&quot;</span>&gt;</span><br><span class="line">  &lt;link rel<span class="operator">=</span><span class="string">&quot;dns-prefetch&quot;</span> href<span class="operator">=</span><span class="string">&quot;//cdn.example.com&quot;</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，使用标签并设置rel属性为dns-prefetch，将href属性设置为需要预解析的域名。注意，域名前需要加上&#x2F;&#x2F;，表示使用当前页面的协议（HTTP或HTTPS）。</p><p>使用DNS预解析可以在一定程度上提高网页的加载速度和用户体验，但需要注意的是，过多的预解析可能会消耗用户的网络资源和带宽。因此，在实际应用中，应该根据实际需求合理地使用DNS预解析。</p><h2 id="什么是低代码？你用过哪些低代码工具？"><a href="#什么是低代码？你用过哪些低代码工具？" class="headerlink" title="什么是低代码？你用过哪些低代码工具？"></a>什么是低代码？你用过哪些低代码工具？</h2><p>低代码（Low-Code）是一种软件开发方法，它允许开发者通过可视化界面、拖拽组件和一些简单的逻辑配置来构建应用程序，而无需编写大量的代码。低代码平台的目标是提高开发效率，降低开发难度，使非专业开发人员（如业务分析师、产品经理等）也能参与到应用程序的开发过程中。</p><p>低代码平台的主要特点包括：</p><ol><li>可视化界面：低代码平台通常提供可视化的界面设计工具，开发者可以通过拖拽组件、配置属性等方式来构建应用程序界面。</li><li>预构建组件：低代码平台提供一系列预构建的组件和模板，开发者可以直接使用这些组件，而无需从头编写代码。</li><li>逻辑配置：低代码平台允许开发者通过图形化界面或简单的脚本语言来配置应用程序的逻辑，降低了编程难度。</li><li>一键部署：低代码平台通常提供一键部署功能，开发者可以轻松地将应用程序发布到目标环境中。</li></ol><p>一些常见的低代码工具和平台包括：</p><ol><li>OutSystems：一款功能强大的低代码开发平台，适用于构建企业级应用程序，支持Web和移动应用开发。</li><li>Appian：提供低代码开发和业务流程管理功能，适用于构建企业应用程序，特别是需要复杂流程控制的场景。</li><li>Microsoft Power Apps：Microsoft推出的低代码应用程序开发平台，可以轻松地与其他Microsoft 365服务集成。</li><li>Mendix：一款低代码开发平台，提供丰富的预构建组件和可视化开发工具，适用于构建企业应用程序。</li></ol><p>虽然低代码平台可以提高开发效率，但在某些场景下，它们可能无法满足复杂的定制需求或实现高度优化的性能。因此，在选择低代码平台时，需要根据项目需求和团队技能来权衡</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day25</title>
      <link href="/2023/03/17/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day25/"/>
      <url>/2023/03/17/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day25/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="怎么使用-JS-实现元素拖拽功能？"><a href="#怎么使用-JS-实现元素拖拽功能？" class="headerlink" title="怎么使用 JS 实现元素拖拽功能？"></a>怎么使用 JS 实现元素拖拽功能？</h2><p>要使用JavaScript实现元素的拖拽功能，您可以按照以下步骤操作：</p><p>为需要拖拽的元素添加mousedown、mousemove和mouseup事件监听器。 在mousedown事件处理函数中，记录鼠标按下时的位置，以及鼠标相对于元素的位置。 在mousemove事件处理函数中，计算鼠标移动的距离，并更新元素的位置。 在mouseup事件处理函数中，移除mousemove和mouseup事件监听器。 以下是一个简单的实现示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Draggable Element<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#draggable</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">cursor</span>: move;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;draggable&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> draggableElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;draggable&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        draggableElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 记录鼠标按下时的位置</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> startX = event.<span class="property">clientX</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> startY = event.<span class="property">clientY</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 计算鼠标相对于元素的位置</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> offsetX = startX - draggableElement.<span class="property">offsetLeft</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> offsetY = startY - draggableElement.<span class="property">offsetTop</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 处理鼠标移动事件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> <span class="title function_">onMouseMove</span> = (<span class="params">event</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 计算鼠标移动的距离</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> deltaX = event.<span class="property">clientX</span> - startX;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> deltaY = event.<span class="property">clientY</span> - startY;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 更新元素的位置</span></span></span><br><span class="line"><span class="language-javascript">                draggableElement.<span class="property">style</span>.<span class="property">left</span> = <span class="string">`<span class="subst">$&#123;event.clientX - offsetX&#125;</span>px`</span>;</span></span><br><span class="line"><span class="language-javascript">                draggableElement.<span class="property">style</span>.<span class="property">top</span> = <span class="string">`<span class="subst">$&#123;event.clientY - offsetY&#125;</span>px`</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 处理鼠标松开事件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> <span class="title function_">onMouseUp</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onMouseUp);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 添加事件监听器</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, onMouseMove);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseup&#x27;</span>, onMouseUp);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个示例将实现一个简单的拖拽功能，您可以在此基础上根据需要进行调整和优化。注意，这个示例未考虑边界限制和性能优化，请根据实际需求进行相应调整。</p><h2 id="什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？"><a href="#什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？" class="headerlink" title="什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？"></a>什么是回流和重绘？什么场景下会触发？怎么减少回流和重绘？</h2><p>回流（Reflow）和重绘（Repaint）是浏览器渲染过程中的两个关键概念，它们对网页性能产生重要影响。理解回流和重绘以及它们的触发场景有助于我们优化网页性能。</p><p>回流（Reflow）： 回流是当浏览器需要重新计算元素的布局、尺寸和位置时所发生的过程。回流通常发生在以下场景：</p><ol><li>添加或删除可见的DOM元素。</li><li>元素尺寸发生变化，如宽度、高度、边距、填充等。</li><li>页面布局发生变化，如改变窗口大小。</li><li>CSS伪类激活，如:hover。</li><li>计算offsetWidth、offsetHeight等属性。</li></ol><p>重绘（Repaint）： 重绘是浏览器在元素的外观发生变化，但不影响布局时所发生的过程。重绘通常发生在场景：改变元素的颜色、背景、边框等样式，但不影响元素尺寸和位置。</p><p>减少回流和重绘的方法：</p><ol><li>避免频繁操作样式：多次修改样式时，可以使用一个class来修改，或者通过修改style属性进行批量操作。</li><li>避免逐项改变样式：使用CSS的transform、opacity等属性进行动画，而不是改变宽度、高度、位置等会触发回流的属性。</li><li>使用文档片段（DocumentFragment）或者offscreen元素进行批量操作：在对DOM元素进行大量操作时，可以先将它们从文档流中移除，然后在内存中进行操作，最后再插入文档流中。</li><li>避免使用table布局：table布局中的元素发生回流时，会影响到整个表格，从而导致更多的回流。</li><li>对具有复杂动画的元素使用绝对定位：将动画元素脱离文档流，减少回流对其他元素的影响。</li><li>避免频繁访问布局信息：如offsetWidth、offsetHeight等，可以在访问前将这些值缓存起来，避免多次触发回流。</li></ol><p>回流和重绘对性能影响较大，尤其是在移动设备上。因此，优化代码以减少回流和重绘次数是提高网页性能的重要手段。</p><h2 id="什么是-npm？你用过哪些-npm-包？是否开发过自己的-npm-包？"><a href="#什么是-npm？你用过哪些-npm-包？是否开发过自己的-npm-包？" class="headerlink" title="什么是 npm？你用过哪些 npm 包？是否开发过自己的 npm 包？"></a>什么是 npm？你用过哪些 npm 包？是否开发过自己的 npm 包？</h2><p>npm（Node Package Manager）是一个基于Node.js的包管理器，用于管理Node.js项目中的依赖和包。npm提供了一种简单、方便的方式来安装、更新和卸载第三方库和工具，同时还可以用于发布和共享自己开发的包。通过npm，开发者可以轻松地引入各种库，提高开发效率。</p><p>提供一些常见的npm包：</p><ol><li>express：一个简洁、灵活的Node.js Web应用框架，提供了一系列强大的功能来开发Web和API应用。</li><li>react：一个用于构建用户界面的JavaScript库，由Facebook开发，广泛应用于前端开发。</li><li>lodash：一个强大的JavaScript实用库，提供了许多有用的工具函数，如数组操作、对象操作、函数操作等。</li><li>axios：一个基于Promise的HTTP客户端库，用于浏览器和Node.js，提供了简单、易用的API来发起HTTP请求。</li><li>moment：一个用于解析、处理和显示日期和时间的JavaScript库，提供了丰富的API来处理各种日期和时间操作。</li><li>nodemon：一个实用的开发工具，用于监视Node.js应用程序中的文件更改，并在发生更改时自动重启应用。</li></ol><p>开发自己的npm包的过程大致如下：</p><ol><li>创建项目文件夹，并在文件夹中初始化npm项目，使用npm init命令生成package.json文件。</li><li>开发功能模块，确保遵循模块化的原则，编写模块的导出和引入。</li><li>编写详细的README文件，说明模块的用途、安装方法、使用方法以及API文档。</li><li>确保项目中包含.gitignore和.npmignore文件，以排除不需要发布到npm的文件和文件夹。</li><li>在npm官网 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 注册一个账号，然后在命令行中使用 <code>npm login</code> 命令登录。</li><li>使用npm publish命令发布包到npm仓库。</li></ol><p>发布后，其他开发者可以通过npm install命令安装和使用您的包。注意在开发过程中遵循语义化版本规范（Semantic Versioning），便于其他开发者理解版本变更。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day24</title>
      <link href="/2023/03/16/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day24/"/>
      <url>/2023/03/16/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day24/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="说说你对-JS-模块化方案的理解，比如-CommonJS、AMD、CMD、ES-Module-分别是什么？"><a href="#说说你对-JS-模块化方案的理解，比如-CommonJS、AMD、CMD、ES-Module-分别是什么？" class="headerlink" title="说说你对 JS 模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？"></a>说说你对 JS 模块化方案的理解，比如 CommonJS、AMD、CMD、ES Module 分别是什么？</h2><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p><code>AMD</code>是一种<strong>异步模块加载规范</strong>，专为浏览器端设计，其全称是<code>Asynchronous Module Definition</code>，中文名称是异步模块定义。<code>AMD</code>规范定义模块的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(id?, dependencies?, factory)</span><br></pre></td></tr></table></figure><p>浏览器并<strong>不支持</strong><code>AMD模块</code>，在浏览器端，需要借助<code>RequireJs</code>才能加载AMD模块。<code>RequireJS</code>是使用最广泛的AMD模块加载器，但目前的新系统基本不再使用<code>RequireJS</code>,因为大部分库都会提供对AMD模块的支持。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名，无依赖模块，文件名就是模块名</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="comment">//此处省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个<strong>匿名AMD模块</strong>，假设代码位于<code>clone.js</code>文件中，那么在<code>index.js</code>文件中可以像下面这样使用上面定义的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;clone&#x27;</span>], <span class="keyword">function</span>(<span class="params">clone</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="title function_">clone</span>(a)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="#CommonJS"></a><a href="http://knif.gitee.io/daodao-knowledge/pages/a5dbfb/#commonjs">#</a>CommonJS</h4><p><code>CommonJS</code>是一种<strong>同步模块加载规范</strong>，目前主要用于<code>Node.js</code>环境中(<code>Sea.js</code>使用的也是<code>CommonJS</code>规范)。<code>CommonJS</code>规范中定义模块的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="comment">//此处省略代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在<code>Node.js</code>中，外面的<code>define</code>包裹函数是系统自动生成的，不需要开发者自己书写。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名，无依赖模块，文件名就是模块名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">//此处省略代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = clone</span><br></pre></td></tr></table></figure><p>在<code>Node.js</code>环境下，假设上面的代码位于<code>clone.js</code>文件中，那么在<code>index.js</code>文件中可以像下面代码这样使用上面代码定义的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">require</span>(<span class="string">&#x27;./clone.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">clone</span>(a)</span><br></pre></td></tr></table></figure><h4 id="UMD"><a href="#UMD" class="headerlink" title="#UMD"></a><a href="http://knif.gitee.io/daodao-knowledge/pages/a5dbfb/#umd">#</a>UMD</h4><p><code>UMD</code>是一种<strong>通用模块加载规范</strong>，其全称是<code>Universal Module Definition</code>，中文名称是<strong>通用模块定义</strong>。UMD想要解决的问题和其名称所传递的意思是一致的，它并不是一种新的规范，而是对前面介绍的3种模块规范(原始模块、AMD,CommonJS)的整合，支持UMD规范的库可以在任何模块环境中工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="title function_">factory</span>(root)</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">//AMD</span></span><br><span class="line">    <span class="title function_">define</span>(<span class="string">&#x27;clone&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> clone</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//CommonJS</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = clone</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 原始模块</span></span><br><span class="line">    <span class="keyword">var</span> _clone = root.<span class="property">clone</span></span><br><span class="line"></span><br><span class="line">    clone.<span class="property">noConflict</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(root.<span class="property">clone</span> === clone) &#123;</span><br><span class="line">        root.<span class="property">clone</span> = _clone</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处省略代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，<code>UMD</code>规范只是对不同模块规范的简单整合，稍微不同的是，代码中给原始模块增加了<code>noConflict</code>方法，使用<code>noConflict</code>方法可以解决全局名称冲突的问题。</p><h4 id="ES-Module"><a href="#ES-Module" class="headerlink" title="#ES Module"></a><a href="http://knif.gitee.io/daodao-knowledge/pages/a5dbfb/#es-module">#</a>ES Module</h4><p>ECMAScript 2015带来了原生的模块系统——<code>ES Module</code>。目前，部分浏览器已经支持直接使用ES Module，而不兼容的浏览器则可以通过构建工具来使用。</p><p><code>ES Module</code>的语法更加简单，只需要在函数前面加上关键字<code>export</code>即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="comment">//此处省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设上面的代码位于<code>clone.js</code>文件中，那么在<code>index.js</code>文件中可以像下面代码这样引用<code>clone.js</code>文件中的<code>clone</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;clone&#125; <span class="keyword">from</span> <span class="string">&#x27;./clone.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">clone</span>(a)</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a href="http://knif.gitee.io/daodao-knowledge/pages/a5dbfb/#%E6%80%BB%E7%BB%93">#</a>总结</h4><p>对于开源库来说，为了满足各种模块使用者的需求，需要对每种模块提供支持。开源库可以提供两个入口文件，这两个入口文件及其支持的模块如下:</p><table><thead><tr><th>入口文件</th><th>支持的模块</th></tr></thead><tbody><tr><td>index.js</td><td>原始模块，AMD模块，CommonJS模块，UMD模块</td></tr><tr><td>index.esm.js</td><td>ES Module</td></tr></tbody></table><h2 id="如果使用-Math-random-来计算中奖概率，会有什么问题吗？"><a href="#如果使用-Math-random-来计算中奖概率，会有什么问题吗？" class="headerlink" title="如果使用 Math.random() 来计算中奖概率，会有什么问题吗？"></a>如果使用 Math.random() 来计算中奖概率，会有什么问题吗？</h2><p>使用 Math.random() 来计算中奖概率是不可靠的。因为 Math.random() 函数的随机性并不是真正的随机，它是基于一个种子值（seed）生成的伪随机数序列。如果你在相同的环境中使用相同的种子值，那么生成的随机数序列是相同的。因此，如果不使用合适的种子值生成伪随机数，就有可能出现概率计算错误的情况。</p><p>为了准确地计算中奖概率，可以使用其他的随机数生成算法，比如 crypto 模块中的 randomBytes() 方法，它可以生成真正的随机数。例如，如果要计算 1&#x2F;1000 的中奖概率，可以使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isWinner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rand = crypto.<span class="title function_">randomBytes</span>(<span class="number">4</span>).<span class="title function_">readUInt32BE</span>();</span><br><span class="line">  <span class="keyword">return</span> rand &lt; <span class="number">429496729</span>; <span class="comment">// 429496729 = Math.pow(2, 32) / 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用 crypto.randomBytes() 生成 4 个字节的随机数，然后将它转换为无符号的 32 位整数，判断该随机数是否小于 429496729，如果小于，则认为中奖了。这样计算中奖概率是比较准确的。</p><h2 id="浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？"><a href="#浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？" class="headerlink" title="浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？"></a>浏览器的本地存储方式有哪些，有什么区别，分别有哪些应用场景？</h2><p>浏览器的本地存储方式主要有以下几种：</p><ol><li>Cookie：Cookie 是浏览器中最古老的本地存储方式，它可以存储少量的文本数据，并在之后的 HTTP 请求中自动携带发送给服务器。Cookie 可以设置过期时间，也可以设置作用域（只在特定域名或路径下有效）。 应用场景：一般用于存储会话信息、用户偏好设置等少量的文本数据。</li><li>LocalStorage：LocalStorage 是 HTML5 新增的本地存储方式，可以存储较大量的数据，数据保存在浏览器本地且不会过期，除非手动删除或清除缓存。 应用场景：适用于存储用户个性化数据、本地数据缓存等。</li><li>SessionStorage：SessionStorage 也是 HTML5 新增的本地存储方式，与 LocalStorage 类似，但是数据只在会话期间有效，会话结束或关闭浏览器后数据会被清除。 应用场景：适用于需要短期保存数据的场景，如表单数据暂存、页面数据缓存等。</li><li>IndexedDB：IndexedDB 是 HTML5 中的一个本地数据库存储方案，可以存储大量结构化数据，支持事务处理和索引查找，功能比较强大。 应用场景：适用于需要离线存储数据、本地数据库操作等。</li><li>Web SQL：Web SQL 是 HTML5 中的另一种本地数据库存储方案，采用 SQL 语句进行数据存储和查询，但是目前已经被弃用，不建议使用。 应用场景：类似于 IndexedDB，适用于需要离线存储数据、本地数据库操作等。</li></ol><p>不同的本地存储方式适用于不同的场景，选择合适的方式可以提高用户体验和网站性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的一些坑</title>
      <link href="/2023/03/16/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2023/03/16/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>今天弄项目，因为电脑有2个github账号，跟着相关教程配置了ssh的设置，<del>但是还是出了问题</del><strong>(结果原因是github的权限设置，要拉取最新才能push)</strong></p><p>以下都是费时间的坑（我菜）</p><h3 id="git-回滚版本"><a href="#git-回滚版本" class="headerlink" title="git 回滚版本"></a>git 回滚版本</h3><p><strong>我要回到过去！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 撤销 commit 操作</span><br><span class="line">git reset --soft HEAD~1 # git reset --soft commit_id</span><br><span class="line"># 撤销 commit 和 add 操作</span><br><span class="line">git reset --mixed HEAD~1 # git reset --mixed commit_id</span><br><span class="line"># 撤销 commit 和 add 操作同时撤销本地已追踪内容的修改</span><br><span class="line">git reset --hard HEAD~1 # git reset --hard commit_id</span><br></pre></td></tr></table></figure><h3 id="github-PR合并commit"><a href="#github-PR合并commit" class="headerlink" title="github PR合并commit"></a>github PR合并commit</h3><p><em><strong>pr太多commit了，不好看</strong></em></p><p>在 Git 中，这种操作就叫做 <strong>变基（rebase）</strong>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p><strong>变基的风险</strong></p><p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p><p><em><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></em></p><p>ps:</p><ul><li>在执行 <code>git rebase</code> 命令之前，请确保当前分支是最新的，并且没有未提交的更改。</li><li>在执行 <code>git rebase</code> 命令之后，请确保你的修改没有破坏代码的正确性，并且没有冲突。</li><li>在执行 <code>git rebase</code> 命令之后，如果你想取消 rebase，可以使用 <code>git rebase --abort</code> 命令。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#找到需要合并的commit的SHA值。可以在GitHub上的提交历史记录中找到</span><br><span class="line"></span><br><span class="line">git rebase -i [commit的hash值]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时会进入一个交互式编辑器，显示需要合并的 commit 列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick abcde commit message 1</span><br><span class="line">squash fghij commit message 2</span><br><span class="line">squash klmno commit message 3</span><br></pre></td></tr></table></figure><p>将除第一个 commit 以外的所有命令从 <strong>pick 改为 squash</strong><br>保存并退出编辑器，Git 会自动合并 commit，并弹出一个编辑器，让你编辑合并后的 commit message</p><p>最后，通过push操作把本地分支推送到远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch name&gt; --force</span><br></pre></td></tr></table></figure><h3 id="git-合并分支"><a href="#git-合并分支" class="headerlink" title="git 合并分支"></a><strong>git 合并分支</strong></h3><p><strong>想要把之前的版本合并到现版本</strong></p><ol><li><p>从主分支（通常是 <code>master</code> 分支）创建一个新的分支（例如 <code>feature-branch</code>），并在该分支上进行开发。</p></li><li><p>在 <code>feature-branch</code> 分支上进行更改和提交，直到完成所需的功能或修复。</p></li><li><p>将主分支更新到最新版本，以确保没有与 <code>feature-branch</code> 分支冲突的更改。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></li><li><p>将 feature-branch 分支合并到主分支上。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge feature-branch</span><br></pre></td></tr></table></figure></li><li><p>如果存在冲突，需要解决冲突并提交更改。在解决冲突之后，使用以下命令完成合并：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li><p>推送主分支和 <code>feature-branch</code> 分支的更改。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push origin feature-branch</span><br></pre></td></tr></table></figure></li></ol><p>这样，你就成功地将 <code>feature-branch</code> 分支合并到主分支上了。</p><h3 id="删除-Git-中的所有提交历史记录"><a href="#删除-Git-中的所有提交历史记录" class="headerlink" title="删除 Git 中的所有提交历史记录"></a>删除 Git 中的所有提交历史记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建 orphan 分支</span><br><span class="line">git checkout --orphan [分支名]</span><br><span class="line"></span><br><span class="line"># 添加需要上传文件</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"># 提交更改</span><br><span class="line">git commit -m &quot;Initial&quot;</span><br><span class="line"></span><br><span class="line"># 删除需要清空提交记录的分支</span><br><span class="line">git branch -D master</span><br><span class="line"></span><br><span class="line"># 将当前分支重命名为需要清空提交记录的分支名</span><br><span class="line">git branch -m master</span><br><span class="line"></span><br><span class="line"># 强制更新存储库</span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><h3 id="commit-常用-type"><a href="#commit-常用-type" class="headerlink" title="commit 常用 type"></a>commit 常用 type</h3><table><thead><tr><th align="left">type</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">feat</td><td align="left">新功能</td></tr><tr><td align="left">fix</td><td align="left">修复 bug</td></tr><tr><td align="left">docs</td><td align="left">修改文档</td></tr><tr><td align="left">style</td><td align="left">代码格式修改</td></tr><tr><td align="left">refactor</td><td align="left">重构（即不是新增功能，也不是修复 bug）</td></tr><tr><td align="left">perf</td><td align="left">更改代码以提高性能</td></tr><tr><td align="left">test</td><td align="left">增加测试</td></tr><tr><td align="left">build</td><td align="left">构建过程或辅助工具的变动</td></tr><tr><td align="left">ci</td><td align="left">修改项目持续集成流程</td></tr><tr><td align="left">chore</td><td align="left">其他类型的提交</td></tr><tr><td align="left">revert</td><td align="left">恢复上一次提交</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day23</title>
      <link href="/2023/03/15/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day23/"/>
      <url>/2023/03/15/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day23/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="有哪些-CSS-性能优化的操作或技巧？"><a href="#有哪些-CSS-性能优化的操作或技巧？" class="headerlink" title="有哪些 CSS 性能优化的操作或技巧？"></a>有哪些 CSS 性能优化的操作或技巧？</h2><ol><li>使用合适的选择器：选择器的复杂度会影响 CSS 渲染性能。尽量使用简单的选择器，避免使用通配符和后代选择器等复杂的选择器。</li><li>避免使用 @import：@import 可以在 CSS 文件中导入其他 CSS 文件，但它会阻塞页面的渲染，影响性能。建议使用 link 标签来引入 CSS 文件。</li><li>避免使用 !important：!important 会影响 CSS 属性的优先级，而且会增加解析和渲染时间。建议尽量避免使用 !important。</li><li>避免使用 inline 样式：inline 样式的优先级最高，但它会增加 HTML 文件的大小，降低页面的加载速度。建议使用外部 CSS 文件和内部样式表。</li><li>压缩和合并 CSS 文件：压缩和合并 CSS 文件可以减小文件大小，提高页面加载速度。可以使用工具例如 CSSMin 和 YUI Compressor 等来进行压缩和合并操作。</li><li>使用 CSS Sprites：CSS Sprites 可以将多个小图片合并成一张大图片，并使用 CSS 来显示不同的部分，减少 HTTP 请求次数，提高页面加载速度。</li><li>避免过度继承：过度继承会导致样式的冗余和继承链的深度增加，影响 CSS 的解析和渲染性能。</li><li>避免使用高消耗的属性和值：某些属性和值的计算成本比较高，例如 box-shadow、border-radius 等，应该尽量避免使用。</li></ol><p>以上是一些常用的 CSS 性能优化操作和技巧，可以帮助提高页面的加载速度和渲染性能</p><h2 id="JS-在什么情况下会存在数字精度丢失的问题，如何解决？"><a href="#JS-在什么情况下会存在数字精度丢失的问题，如何解决？" class="headerlink" title="JS 在什么情况下会存在数字精度丢失的问题，如何解决？"></a>JS 在什么情况下会存在数字精度丢失的问题，如何解决？</h2><p>在 JavaScript 中，数字类型是采用 IEEE 754 标准的双精度浮点数表示的，由于双精度浮点数只有 52 位精度，因此在进行精度较高的数值计算时，可能会出现数字精度丢失的问题。例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">console</span>.log(<span class="number">0</span>.<span class="number">1</span> + <span class="number">0</span>.<span class="number">2</span>); // 输出结果为 <span class="number">0</span>.<span class="number">30000000000000004</span></span><br></pre></td></tr></table></figure><p>可以看到，实际上 0.1 + 0.2 的结果并不等于 0.3，这是因为双精度浮点数的精度限制导致的。在处理货币等需要高精度计算的场景时，这种精度丢失的问题可能会导致计算错误。</p><p>为了解决这个问题，可以采用以下几种方法：</p><ol><li>使用整数进行计算：可以将数字转换成整数进行计算，例如将货币的单位从元转换成分进行计算，避免小数计算带来的精度问题。</li><li>使用第三方库：例如 decimal.js 和 big.js 等第三方库，可以提供更高精度的数字计算功能，避免精度丢失的问题。</li><li>使用 toFixed 方法：可以使用 JavaScript 中的 toFixed 方法将数字转换成指定位数的字符串，例如将 0.1 和 0.2 转换成一位小数的字符串再进行相加，避免精度丢失的问题。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">console</span>.log((<span class="number">0</span>.<span class="number">1</span> + <span class="number">0</span>.<span class="number">2</span>).toFixed(<span class="number">1</span>)); // 输出结果为 <span class="string">&quot;0.3&quot;</span></span><br></pre></td></tr></table></figure><p>总之，在进行精度较高的数值计算时，需要注意 JavaScript 中存在的数字精度丢失问题，并根据具体情况选择合适的解决方案。</p><h2 id="ES6-中的-Reflect-对象有什么用？"><a href="#ES6-中的-Reflect-对象有什么用？" class="headerlink" title="ES6 中的 Reflect 对象有什么用？"></a>ES6 中的 Reflect 对象有什么用？</h2><p>Reflect对象是一个内置对象，它提供了一组用于操作对象的方法</p><ol><li><p>简化了操作对象：Reflect方法是函数式的，与Object方法是命令式的不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> objName = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person,<span class="string">&#x27;name&#x27;</span>).<span class="property">value</span></span><br><span class="line"><span class="keyword">const</span> reflectName = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(person,<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objName) <span class="comment">// &#x27;Tom&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reflectName) <span class="comment">// &#x27;Tom&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>Reflect方法的返回值更加明确，定义属性成功后直接返回布尔值来表示是否设置成功，而Object.defineProperty()会返回obj</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&#x27;gender&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;man&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&#x27;address&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1) <span class="comment">// 返回对象 &#123;name: &#x27;Tom&#x27;,gender: &#x27;man&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2) <span class="comment">// 返回布尔值 true 表示操作成功</span></span><br></pre></td></tr></table></figure></li><li><p>统一了对象操作的API：通过Reflect方法可以操作对象的属性，与Object方法基本类似</p></li><li><p>与Proxy对象进行配合使用：Reflect对象和Proxy对象配合使用，可以实现拦截对象操作，例如使用Reflect.get()方法获取被代理对象的属性，在获取属性值之前可以先进行一些拦截操作，从而实现拦截对象操作的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj,&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target,key,receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取属性<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,key,receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></li><li><p>Reflect内置对象里面还有许许多多的方法API，Reflect对象提供了许多灵活和强大的对象操作方法</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day22</title>
      <link href="/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day22/"/>
      <url>/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day22/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="React-memo-和-useMemo-的用法是什么，有哪些区别？"><a href="#React-memo-和-useMemo-的用法是什么，有哪些区别？" class="headerlink" title="React.memo() 和 useMemo() 的用法是什么，有哪些区别？"></a>React.memo() 和 useMemo() 的用法是什么，有哪些区别？</h2><p>React.memo() 和 useMemo() 是 React 中用于性能优化的两个钩子函数。</p><p>React.memo() 是一个高阶组件，用于优化组件的性能。它会比较组件的新旧 props，如果 props 没有发生改变，则跳过渲染，直接使用上一次渲染的结果。使用 React.memo() 可以避免组件不必要的重新渲染，从而提高应用程序的性能。</p><p>用法示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MemoizedComponent <span class="operator">=</span> React.memo(MyComponent)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>useMemo() 是一个 Hook，用于缓存函数的计算结果。它可以缓存组件的 props 或其他数据的计算结果，只有当依赖项发生改变时才重新计算。</p><p>用法示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedValue = use<span class="constructor">Memo(()</span> =&gt; compute<span class="constructor">ExpensiveValue(<span class="params">a</span>, <span class="params">b</span>)</span>, <span class="literal">[<span class="identifier">a</span>, <span class="identifier">b</span>]</span>);</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>React.memo() 用于优化组件的性能，它会比较组件的新旧 props，如果 props 没有发生改变，则跳过渲染，直接使用上一次渲染的结果。而 useMemo() 用于缓存函数的计算结果，只有当依赖项发生改变时才重新计算。</li><li>React.memo() 是一个高阶组件，必须包裹组件才能使用，而 useMemo() 是一个 Hook，可以在函数组件中使用。</li></ul><p>综上所述，React.memo() 用于缓存组件的渲染结果，从而提高应用程序的性能，而 useMemo() 则用于缓存函数的计算结果，可以在函数组件中使用。</p><h2 id="CSS-有哪些常用单位？这些单位各有什么区别？"><a href="#CSS-有哪些常用单位？这些单位各有什么区别？" class="headerlink" title="CSS 有哪些常用单位？这些单位各有什么区别？"></a>CSS 有哪些常用单位？这些单位各有什么区别？</h2><p>CSS 中常用的单位有以下几种：</p><ol><li>px（像素）：像素是相对于显示器分辨率而言的，是一个固定的单位。1px 可以被理解为显示器上的一个物理像素点，其大小和颜色由显示器自身控制。</li><li>em（相对长度单位）：em 是相对于父元素的字体大小的单位，当父元素没有设置字体大小时，em 相对于浏览器的默认字体大小。</li><li>rem（相对长度单位）：rem 同样是相对长度单位，但相对于根元素（即 html 元素）的字体大小。</li><li>%（百分比）：百分比是相对于父元素的宽度、高度、字体大小等的百分比。</li><li>vw、vh（视口单位）：vw 和 vh 分别代表视口的宽度和高度的百分比。</li><li>pt（点）：1pt 等于 1&#x2F;72 英寸，常用于打印页面。</li><li>em 和 rem 的区别：em 和 rem 都是相对长度单位，但 em 的大小是相对于其父元素的字体大小，而 rem 的大小则是相对于根元素（即 html 元素）的字体大小。因此，rem 更加稳定，能够更好地控制页面布局和字体大小。</li></ol><p>在使用 CSS 单位时，需要根据实际情况选择合适的单位。一般情况下，像素是最常用的单位，因为它在大多数情况下可以提供良好的显示效果。对于需要在不同设备上适配的情况，可以使用 em、rem 和 vw、vh 等相对单位。</p><h2 id="什么是-TypeScript-中的命名空间和模块？两者有什么区别？"><a href="#什么是-TypeScript-中的命名空间和模块？两者有什么区别？" class="headerlink" title="什么是 TypeScript 中的命名空间和模块？两者有什么区别？"></a>什么是 TypeScript 中的命名空间和模块？两者有什么区别？</h2><p>在 TypeScript 中，命名空间和模块都是用来组织和管理代码的方式。</p><p>命名空间提供了一种将代码划分为逻辑单元的方式，可以避免命名冲突。在命名空间内，所有变量、函数、类等都是私有的，需要使用 export 关键字进行导出，才能被其他代码使用。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块是用来组织和管理代码的方式，与命名空间类似，不同之处在于模块是按文件划分的，一个文件就是一个模块。模块可以使用 export 和 import 关键字来导出和导入代码。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">PI</span>, sayHello, <span class="title class_">Person</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./moduleA&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;world&#x27;</span>); <span class="comment">// Hello, world!</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Alice</span></span><br></pre></td></tr></table></figure><p>命名空间和模块的主要区别在于，命名空间是将代码划分为逻辑单元，而模块是按照文件划分的。在使用模块时，可以使用 import 和 export 进行代码的导入和导出，可以更方便地组织和管理代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day21</title>
      <link href="/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day21/"/>
      <url>/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day21/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="怎么使用-CSS3-来实现动画？你实现过哪些动画？"><a href="#怎么使用-CSS3-来实现动画？你实现过哪些动画？" class="headerlink" title="怎么使用 CSS3 来实现动画？你实现过哪些动画？"></a>怎么使用 CSS3 来实现动画？你实现过哪些动画？</h2><p><strong>css3 动画的实现的方案，大概有以下方案</strong>：</p><ul><li><p>js 的 animation() 方法实现动画</p></li><li><p>@keyframes + animation：这是一个实现动画的组合，必须一起使用。</p><ol><li><p>@keyframes——创建动画</p><p>（1）在 @keyframes 中用 from 和 to 创建动画</p><p>（2）在 @keyframes 中用 “百分比” 创建动画</p><p>（3）将 @keyframes 嵌套进要添加动画的元素的样式里</p></li><li><p>animation 执行动画</p></li></ol></li><li><p>transition：表示过渡。transition 可以单独使用</p></li><li><p>transform：表示变形。使用 transform 实现动画时有两种选择：</p></li><li><p>transform + transition：一次性动画。transform 定义行为，transition 驱动，但一次仅能驱动一次。</p></li><li><p>transform + @keyframes + animation：支持循环动画。在 @keyframes 里使用 transform 定义行为，animation 驱动，可充分调整动画的实现，包括：指定动画任意的执行次数，指定动画的结束与开始的状态等等。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.iconfont-loadding</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: start_loadding <span class="number">800ms</span> linear <span class="number">100ms</span> infinite normal none running;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> start_loadding &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);&#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transition 和 animation 实现动画的区别：</strong> transition：需要触发一个事件才执行动画。 animation：自动执行动画，可循环执行。</p><h2 id="Vue-Router-路由有哪些模式？各模式有什么区别？"><a href="#Vue-Router-路由有哪些模式？各模式有什么区别？" class="headerlink" title="Vue Router 路由有哪些模式？各模式有什么区别？"></a>Vue Router 路由有哪些模式？各模式有什么区别？</h2><p>Vue Router 路由有三种模式：</p><ol><li>hash 模式：使用 URL 中的 hash（即 # 后面的内容）来作为路由路径。这种模式下，页面不会重新加载，只会更新 hash 值，并触发路由变化，从而渲染对应的组件。</li><li>history 模式：使用 HTML5 中新增的 History API 来管理浏览历史记录，从而实现页面的前进和后退。在这种模式下，URL 中不会带有 # 号，而是使用真实的 URL 路径来作为路由路径。</li><li>abstract 模式：在不需要基于浏览器的 API 时，可以使用这种模式。在这种模式下，路由器并不会监听 URL 变化，而是通过调用 router.replace 或 router.push 来进行导航。</li></ol><p>区别：</p><ol><li>hash 模式可以兼容较老的浏览器，但 URL 中会带有 # 号。</li><li>history 模式无需带有 # 号，更加美观，但需要后端支持，否则刷新页面会导致 404 错误。</li><li>abstract 模式主要用于一些特定场景，例如在使用 Node.js 时，可以使用 abstract 模式来构建路由。</li></ol><p>一般来说，如果需要支持较老的浏览器，或者不需要后端支持，可以使用 hash 模式；否则建议使用 history 模式。</p><h2 id="如何使用-JS-判断某个字符串长度（要求支持-Emoji-表情）？"><a href="#如何使用-JS-判断某个字符串长度（要求支持-Emoji-表情）？" class="headerlink" title="如何使用 JS 判断某个字符串长度（要求支持 Emoji 表情）？"></a>如何使用 JS 判断某个字符串长度（要求支持 Emoji 表情）？</h2><p>利用正则表达式将emoji替换成单字符的符号，然后再获取len就是正确的length了。</p><blockquote><p>replace不会影响原字符串的内容</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = <span class="string">&quot;H😋&quot;</span>;</span><br><span class="line">const len = str.<span class="built_in">replace</span>(<span class="regexp">/\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F]/g</span>,<span class="string">&quot;-&quot;</span>).<span class="built_in">length</span>;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(len)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h2><p>ES6大幅增强了对字符串的处理能力。 借用数组，可以快速判断带有emoji字符的字符串长度。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">str</span> = <span class="string">&quot;A😋&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> arr = Array.<span class="keyword">from</span>(<span class="built_in">str</span>);</span><br><span class="line">console.log(<span class="built_in">str</span>.length,arr.length)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>多码点的emoji比如👨‍👩‍👧，会显示长度为5，这是因为unicode的约定导致的，详情可看阮一峰的这篇博文 <a href="http://www.ruanyifeng.com/blog/2017/04/emoji.html">http://www.ruanyifeng.com/blog/2017/04/emoji.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day20</title>
      <link href="/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day20/"/>
      <url>/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day20/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="use-strict-是什么？有什么作用？"><a href="#use-strict-是什么？有什么作用？" class="headerlink" title="use strict 是什么？有什么作用？"></a>use strict 是什么？有什么作用？</h2><p>“use strict” 是 ECMAScript 5 引入的一种严格模式，它用于指示 JavaScript 引擎采用更严格的解析和执行模式。</p><p>当在 JavaScript 代码中使用 “use strict” 声明时，代码将会在严格模式下执行。严格模式包含了一些额外的规则和限制，有助于开发者避免一些常见的错误。</p><p>使用 “use strict” 的主要作用包括：</p><ol><li>消除 JavaScript 中的一些不合理、不安全的语法，减少代码出错的可能性。</li><li>防止使用未声明的变量、函数，强制开发者进行声明。</li><li>强制函数中的 this 值只能在函数内部使用，避免在全局作用域中误用 this 值。</li><li>禁止删除变量、函数等，避免意外删除重要的变量和函数。</li><li>提高代码性能，因为 JavaScript 引擎可以更好地进行优化。</li></ol><p>使用 “use strict” 的方式有两种：</p><ol><li>在 JavaScript 文件开头使用 “use strict”。</li><li>在函数体内第一条语句中使用 “use strict”。</li></ol><p>例如，在 JavaScript 文件开头使用 “use strict” 的方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在函数体内第一条语句中使用 “use strict” 的方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，”use strict” 是一种在 JavaScript 中使用严格模式的方法，它可以提高代码的可靠性和性能，避免一些常见的错误。</p><h2 id="什么是前后端分离？它有什么优点和缺点？"><a href="#什么是前后端分离？它有什么优点和缺点？" class="headerlink" title="什么是前后端分离？它有什么优点和缺点？"></a>什么是前后端分离？它有什么优点和缺点？</h2><p>前后端分离是指将前端和后端分别进行独立开发和部署。使前端和后端分别由不同的开发团队负责，通过 API 接口进行数据交互。前端负责页面展示和用户交互，后端负责业务逻辑和数据存储，两者通过 API 进行通信。</p><p>前后端分离的优点包括：</p><ol><li>分工明确：前端和后端分别由不同的开发团队负责，各司其职，有利于开发流程的管理和控制。</li><li>前后端解耦：前后端分离可以使前端和后端解耦，前端只关注页面展示和用户交互，后端只关注业务逻辑和数据存储，有利于模块化开发和维护。</li><li>更好的性能和用户体验：前后端分离可以使前端采用现代化的前端框架和技术，提高网站的性能和用户体验。</li><li>更好的可扩展性：前后端分离可以使后端提供更丰富的 API，方便前端进行开发和维护，同时也使得后端更易于扩展和修改。</li></ol><p>前后端分离的缺点包括：</p><ol><li>开发难度增加：前后端分离需要前端和后端分别进行开发，需要更多的协调和沟通，开发难度增加。</li><li>维护难度增加：前后端分离使得前端和后端的代码分离，需要分别进行维护，维护难度增加。</li><li>安全问题：前后端分离可能会导致一些安全问题，例如跨站点脚本攻击（XSS）和跨站点请求伪造（CSRF），需要采取相应的安全措施来解决。</li></ol><p>总之，前后端分离有其优点和缺点。前后端分离可以提高开发效率、网站性能和用户体验，但也可能会增加开发和维护的难度，需要采取相应的措施来解决。</p><h2 id="端性能优化指标有哪些？怎么进行性能检测？"><a href="#端性能优化指标有哪些？怎么进行性能检测？" class="headerlink" title="端性能优化指标有哪些？怎么进行性能检测？"></a>端性能优化指标有哪些？怎么进行性能检测？</h2><p><img src="/img/Snipaste_2023-03-13_22-52-50.png"></p><p>前端性能优化主要是通过一系列技术手段和优化策略来提升网站或应用的性能，从而提高用户的体验。下面列举一些常见的前端性能优化的指标和性能检测的方法：</p><ol><li>加载速度：网站或应用的加载速度是用户体验的重要因素。可以使用工具（如 WebPagetest、PageSpeed Insights）来测试网站或应用的加载速度，并通过优化图片大小、减少 HTTP 请求、使用浏览器缓存等方式来提升加载速度。</li><li>渲染速度：渲染速度是指页面加载完成后页面内容渲染的速度。可以使用 Chrome 开发者工具中的 Performance 面板来检测页面渲染速度，并通过减少 DOM 操作、使用 CSS3 动画、减少 JavaScript 的执行时间等方式来提升渲染速度。</li><li>响应速度：响应速度是指网站或应用处理请求的速度。可以使用工具（如 Pingdom、GTmetrix）来测试响应速度，并通过优化服务器响应时间、压缩 JavaScript 和 CSS 文件等方式来提升响应速度。</li><li>可访问性：可访问性是指网站或应用是否易于使用和访问。可以通过使用 HTML5、WAI-ARIA 标准、有意义的网页标题、有意义的链接等方式来提高可访问性。</li><li>移动端性能：随着移动设备的普及，移动端性能越来越重要。可以使用工具（如 Google Mobile-Friendly Test）来测试移动端性能，并通过使用响应式设计、优化图片和视频大小、使用 viewport meta 标签等方式来提高移动端性能。</li></ol><p>总结：前端性能优化指标包括加载速度、渲染速度、响应速度、可访问性和移动端性能等方面。可以使用各种工具来检测这些指标，并采取相应的优化策略来提高网站或应用的性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day19</title>
      <link href="/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day19/"/>
      <url>/2023/03/13/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day19/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="为什么-JS-要被设计为单线程？"><a href="#为什么-JS-要被设计为单线程？" class="headerlink" title="为什么 JS 要被设计为单线程？"></a>为什么 JS 要被设计为单线程？</h2><p>JS 被设计为单线程的主要原因是为了避免多线程编程所带来的复杂性。如果 JS 是多线程的，那么在处理并发问题时，需要考虑锁、同步等一系列复杂的问题，这会增加代码的复杂度和开发难度。</p><p>此外，JS 最初是为了解决网页交互的问题而诞生的，而网页交互的需求大部分是基于用户事件的，比如点击按钮、输入文本等。这些操作的响应速度要求很高，如果在响应事件的同时还要处理其他任务，可能会导致网页卡顿、响应变慢等用户体验不佳的问题。</p><p>因此，为了避免多线程所带来的复杂性和降低开发难度，并且满足网页交互的高响应速度需求，JS 被设计为单线程。虽然单线程有局限性，但是可以通过异步编程、事件循环机制等技术手段来实现高效的并发处理。</p><h2 id="TypeScript-中的-Declare-关键字有什么用？"><a href="#TypeScript-中的-Declare-关键字有什么用？" class="headerlink" title="TypeScript 中的 Declare 关键字有什么用？"></a>TypeScript 中的 Declare 关键字有什么用？</h2><p>TypeScript 中的 declare 关键字用于声明一个变量、函数、类等的类型信息，但不实现其具体实现。它主要用于在编译时进行静态类型检查，并在编译后移除声明的代码，以减少 JavaScript 文件的大小。</p><p>使用 declare 关键字声明的类型信息可以是任何类型，如对象、函数、类、变量、命名空间等。常见的使用场景有：</p><p>声明全局变量或模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明模块</span></span><br><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;lodash&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn: <span class="built_in">Function</span>, wait: <span class="built_in">number</span></span>): <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明外部的 JavaScript 库</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;some-library&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params"></span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">someVariable</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明命名空间</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">myFunction</span><span class="params">()</span>: void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 declare 关键字，可以让 TypeScript 在编译时检查代码的类型信息，并避免一些类型错误。同时，也可以提高代码的可读性和维护性。</p><h2 id="什么是-Node-js-中的-process？它有哪些方法和应用场景？"><a href="#什么是-Node-js-中的-process？它有哪些方法和应用场景？" class="headerlink" title="什么是 Node.js 中的 process？它有哪些方法和应用场景？"></a>什么是 Node.js 中的 process？它有哪些方法和应用场景？</h2><p>在 Node.js 中，process 是一个全局变量，它提供了与当前 Node.js 进程相关的信息和控制。process 对象是 EventEmitter 的一个实例，因此它可以使用 EventEmitter 的 API，例如注册事件监听器和触发事件。</p><p>process 对象的一些常用方法和属性：</p><ul><li>process.argv：返回一个数组，其中包含命令行参数。第一个元素是 Node.js 可执行文件的路径，第二个元素是正在执行的 JavaScript 文件的路径，后面的元素是命令行参数。</li><li>process.env：返回一个包含当前 Shell 环境变量的对象。</li><li>process.exit([code])：终止 Node.js 进程。如果指定了 code，那么进程将以 code 退出。</li><li>process.cwd()：返回当前工作目录的路径。</li><li>process.chdir(directory)：将 Node.js 进程的工作目录更改为 directory。</li><li>process.pid：返回 Node.js 进程的进程 ID。</li><li>process.nextTick(callback[, arg1][, arg2][, …])：将 callback 添加到下一个 tick 队列。callback 会在当前操作完成后、事件循环继续之前调用。</li><li>process.on(event, listener)：注册事件监听器。常用的事件包括 “exit”、”uncaughtException”、”SIGINT” 等。</li></ul><p>process 对象的应用场景：</p><ul><li>监听进程退出事件，执行资源清理操作。</li><li>通过 process.argv 读取命令行参数。</li><li>通过 process.env 读取环境变量。</li><li>通过 process.cwd 和 process.chdir 修改 Node.js 进程的工作目录。</li><li>通过 process.pid 获取进程 ID。</li><li>通过 process.nextTick 将某个操作放到下一个 tick 队列中，以实现异步执行。</li></ul><p>总之，process 对象提供了与 Node.js 进程相关的许多信息和控制，是 Node.js 编程中不可或缺的一部分。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day18</title>
      <link href="/2023/03/09/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day18/"/>
      <url>/2023/03/09/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day18/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="Vue-Router-的-route-和-router-对象有什么区别？"><a href="#Vue-Router-的-route-和-router-对象有什么区别？" class="headerlink" title="Vue Router 的 $route 和 $router 对象有什么区别？"></a>Vue Router 的 $route 和 $router 对象有什么区别？</h2><p>在 Vue.js 中，$route 和 $router 都是 Vue Router 提供的对象，但它们的作用不同。</p><p>$route 对象代表着当前激活的路由信息，它包含了当前 URL 解析得到的信息，如当前路径、参数、查询参数等。$route 对象是一个只读对象，我们无法通过改变 $route 对象来改变当前路由。</p><p>$router 对象则是 Vue Router 的实例对象，它负责管理整个路由的状态，包括当前路径、路由参数、路由切换等。$router 对象可以通过编程的方式来改变当前路由，如通过 $router.push()、$router.replace()、$router.go() 等方法。</p><p>总的来说，$route 对象是获取当前路由信息的方式，$router 对象则是控制当前路由状态的方式。</p><h2 id="介绍下从-HTTP-x2F-1-0、HTTP-x2F-1-1-到-HTTP-x2F-2-再到-HTTP-x2F-3-的演化过程，各个阶段相对前一阶段做了哪些优化"><a href="#介绍下从-HTTP-x2F-1-0、HTTP-x2F-1-1-到-HTTP-x2F-2-再到-HTTP-x2F-3-的演化过程，各个阶段相对前一阶段做了哪些优化" class="headerlink" title="介绍下从 HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程，各个阶段相对前一阶段做了哪些优化"></a>介绍下从 HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程，各个阶段相对前一阶段做了哪些优化</h2><p>HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程主要是为了解决 HTTP 协议在网络传输过程中出现的一些问题，提高网络传输效率和性能。</p><p>HTTP&#x2F;1.0 是最早的 HTTP 协议，它使用一条长连接（keep-alive）传输一个请求和响应，存在以下问题：</p><ul><li>队头阻塞问题：因为只有一个连接，所以如果有一个请求被阻塞，后续请求也会被阻塞。</li><li>无法多路复用：只能按顺序传输一个请求和响应，无法同时传输多个请求和响应。</li><li>每次请求需要新建连接：每次请求都需要新建连接，连接的建立和关闭过程会消耗时间。</li></ul><p>HTTP&#x2F;1.1 引入了以下优化：</p><ul><li>持久连接：即连接重用，通过一个 TCP 连接传输多个请求和响应，减少了连接建立和关闭的时间。</li><li>分块传输编码（chunked）：把响应数据分成多个块，每个块前面加上长度信息，便于客户端逐步接收。</li><li>虚拟主机（Virtual Host）：通过在请求头中添加 Host 字段来区分不同的主机。</li></ul><p>HTTP&#x2F;2 引入了以下优化：</p><ul><li>多路复用：允许同时通过同一个连接并行传输多个请求和响应，解决了队头阻塞问题。</li><li>二进制分帧：将传输的数据分成一个个二进制帧，每个帧都有自己的 ID，可以独立传输，解决了队头阻塞问题，提高了传输效率。</li><li>头部压缩：使用 HPACK 算法对头部信息进行压缩，减少了头部信息的传输量。</li></ul><p>HTTP&#x2F;3 引入了以下优化：</p><ul><li>QUIC 协议：使用 QUIC 协议替代 TCP，支持更快的连接建立和更快的重传，能够解决 TCP 队头阻塞和 TCP 握手延迟的问题。</li><li>数据流分离：将一个连接分成多个数据流，每个数据流都有独立的 ID，可以独立控制和传输数据。</li></ul><p>总的来说，HTTP&#x2F;1.0、HTTP&#x2F;1.1 到 HTTP&#x2F;2 再到 HTTP&#x2F;3 的演化过程主要是从连接的角度进行了优化，提高了并发能力和传输效率，提高了用户体验。</p><h2 id="什么是-CSS-工程化？你用过哪些相关的工具？"><a href="#什么是-CSS-工程化？你用过哪些相关的工具？" class="headerlink" title="什么是 CSS 工程化？你用过哪些相关的工具？"></a>什么是 CSS 工程化？你用过哪些相关的工具？</h2><p>CSS 工程化是指将 CSS 在项目中进行模块化、组件化、可维护性、可重用性等方面的处理，以达到工程化管理 CSS 的目的。</p><p>在 CSS 工程化中，通常会使用一些相关的工具来辅助管理 CSS，常用的工具包括：</p><ol><li>CSS 预处理器：如 Sass、Less、Stylus 等，可以通过变量、函数、混合等方式，提高 CSS 的可维护性和可重用性。</li><li>CSS 后处理器：如 PostCSS，可以用来处理 CSS 代码，通过插件的形式可以实现一些自动化处理，如自动添加前缀、压缩 CSS 等。</li><li>CSS 模块化工具：如 CSS Modules、styled-components 等，可以将 CSS 样式与组件代码结合在一起，提高 CSS 的可维护性和可重用性。</li><li>CSS 命名规范：如 BEM、SMACSS、OOCSS 等，可以通过规范化 CSS 的命名方式，提高 CSS 的可读性和可维护性。</li></ol><p>通过使用这些工具，可以提高 CSS 的可维护性、可重用性和可读性，从而使得前端开发更加高效、简洁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day17</title>
      <link href="/2023/03/09/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day17/"/>
      <url>/2023/03/09/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day17/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="怎么解决跨域问题？"><a href="#怎么解决跨域问题？" class="headerlink" title="怎么解决跨域问题？"></a>怎么解决跨域问题？</h2><p>跨域问题（Cross-Origin Resource Sharing，CORS）是由于浏览器的同源策略（Same-Origin Policy）导致的。同源策略指的是，如果两个 URL 的协议、主机名和端口号都相同，那么它们就是同源的，否则就是跨域的。当网页发起跨域请求时，浏览器会根据同源策略限制请求。解决跨域问题的方法有以下几种：</p><ol><li><p><strong>JSONP（JSON with Padding）</strong></p><p>SONP 是一种跨域请求数据的方式，它利用了 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性，可以从不同的域名请求数据。实现原理是在服务端生成一个 JavaScript 函数，客户端使用 <code>&lt;script&gt;</code> 标签请求该函数，服务端返回该函数的调用，并将需要传输的数据作为函数参数传入。</p></li><li><p><strong>CORS（Cross-Origin Resource Sharing）</strong></p><p>CORS 是一种通过添加一些 HTTP 头来允许浏览器跨域访问资源的机制，主要是服务端配置。服务端需要在响应头中添加 <code>Access-Control-Allow-Origin</code> 和其他一些参数，指示允许哪些域名进行跨域请求。</p></li><li><p><strong>反向代理</strong></p><p>反向代理是将客户端的请求转发到真正的服务端，从而解决跨域问题。反向代理服务器和真正的服务端在同一个域名下，客户端的请求只需要向反向代理服务器发起，由反向代理服务器将请求转发到真正的服务端，最后将响应返回给客户端。</p></li><li><p><strong>WebSocket</strong></p><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，可以用于跨域通信。由于 WebSocket 协议并不受同源策略的限制，因此可以实现跨域通信。</p><p>总的来说，不同的解决方案有各自的优缺点，应根据实际情况选择最适合的方式。例如，如果需要在客户端和服务端之间进行实时通信，WebSocket 是最佳选择；如果只需要在客户端发起简单的 GET 请求，可以使用 JSONP 等方式。</p></li></ol><h2 id="什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？"><a href="#什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？" class="headerlink" title="什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？"></a>什么是前端路由？什么时候适合使用前端路由？它有哪些优点和缺点？</h2><h3 id="什么是前端路由？"><a href="#什么是前端路由？" class="headerlink" title="什么是前端路由？"></a>什么是前端路由？</h3><p>前端路由是指：在前端中使用JavaScript实现的页面切换路由系统，它可以根据URL的变化，通过修改DOM来实现单页面应用SPA的页面切换效果，无需每次请求页面时都要从服务器获取完整的HTML页面</p><p>在传统的Web应用中，每次点击页面链接或刷新页面时，浏览器都会向服务器发送请求，接收服务器返回的HTML页面，而在使用前端路由的SPA单页面应用中，页面的切换是通过JavaScript动态修改DOM内容来实现的，这样可以避免每次都要向服务器请求页面时的开销，从而提高页面的响应速度和用户体验</p><p>我是这样理解的(不知道对不对) ：传统的Web应用，将所有的 HTML、CSS 和 JavaScript 文件都存放在服务器上，然后网页切换页面时，每次都要发送请求来接收服务器响应回来的HTML页面。而使用前端路由的SPA单页面应用，是第一次加载网页时，发送http请求，请求服务器返回HTML、CSS、JavaScript文件等静态资源，这些文件被下载到浏览器中，并存储在浏览器的缓存中，当用户在SPA单页面应用进行页面切换时，前端路由会根据浏览器中对应URL文件的路径信息，动态地加载相应的JavaScript文件，并执行里面的逻辑来更新切换页面内容。</p><h3 id="什么时候适合使用前端路由？"><a href="#什么时候适合使用前端路由？" class="headerlink" title="什么时候适合使用前端路由？"></a>什么时候适合使用前端路由？</h3><p>前端路由适合用于构建单页面应用，特别是需要快速响应用户操作，避免不必要的页面刷新应用，例如需要高度交互的应用，如社交网络，音乐播放器</p><h3 id="它有哪些优点和缺点？"><a href="#它有哪些优点和缺点？" class="headerlink" title="它有哪些优点和缺点？"></a>它有哪些优点和缺点？</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>快速响应：前端路由进行页面切换时不需要向服务器发送http请求，从而快速响应用户操作，提高加载速度</li><li>降低服务器压力：采用前端路由，降低了请求次数，减轻了服务器的负担。</li><li>提高应用的交互性：前端路由实现页面无缝切换，避免了传统应用中页面卡顿白屏等现象</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不利于SEO，由于前端路由是根据文件里面的URL修改DOM来切换，而不是加载新的HTML页面，所以不利于搜索引擎的搜索。</li><li>初次加载慢：由于前端路由需要在初次加载时候将所有的静态资源（HTML、CSS、JavaScript）文件都加载到客户端，因此首次加载时间较长，影响用户体验</li><li>复杂度高：前端路由需要在客户端处理好切换页面逻辑以及前进后退等操作，增加了应用的复杂度。</li></ol><h2 id="什么是-Vuex？使用-Vuex-有哪些好处？"><a href="#什么是-Vuex？使用-Vuex-有哪些好处？" class="headerlink" title="什么是 Vuex？使用 Vuex 有哪些好处？"></a>什么是 Vuex？使用 Vuex 有哪些好处？</h2><p>Vuex是Vue.js框架中用于实现集中式状态管理的插件。它的主要作用是在多个组件之间共享状态，并且提供了一些工具来方便地管理应用程序的状态。</p><p>使用Vuex可以将应用程序的状态存储在一个集中的地方，从而使状态管理更加容易、可维护性更高。它还提供了一些工具来简化状态的更改和操作，例如：在组件中使用mutations来修改状态，或者使用actions来异步操作数据。</p><p>使用Vuex的好处包括：</p><ol><li>集中化的状态管理：将应用程序的状态集中存储在一个地方，可以方便地进行状态管理和维护。</li><li>易于调试：使用Vuex可以方便地跟踪和记录状态的更改历史，有助于快速诊断和解决问题。</li><li>状态共享：在多个组件之间共享状态，避免了组件之间繁琐的传值，提高了组件之间的解耦性。</li><li>插件化：Vuex提供了插件机制，可以方便地扩展和自定义Vuex的功能。</li></ol><p>Vuex的缺点包括：</p><ol><li>增加了学习成本：Vuex相对于直接在组件中管理状态来说，增加了一些学习成本，需要花费时间去学习Vuex的概念和使用方式。</li><li>增加了代码复杂度：在使用Vuex的过程中，需要增加一些额外的代码来管理状态，有时可能会增加代码的复杂度。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day16</title>
      <link href="/2023/03/07/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day16/"/>
      <url>/2023/03/07/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day16/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="什么是箭头函数？能使用-new-来创建箭头函数么？"><a href="#什么是箭头函数？能使用-new-来创建箭头函数么？" class="headerlink" title="什么是箭头函数？能使用 new 来创建箭头函数么？"></a>什么是箭头函数？能使用 new 来创建箭头函数么？</h2><p>箭头函数是 ES6 中新增的一种函数定义方式，可以用来简化函数的定义和书写。箭头函数的特点是：简洁的语法、绑定 this 关键字、不能用作构造函数。</p><p>箭头函数使用箭头（&#x3D;&gt;）来定义，基本语法如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">parameters</span>) =&gt; &#123; statements <span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，parameters 是函数的参数列表，可以是一个或多个参数，多个参数之间用逗号分隔；statements 是函数的执行语句，可以是一个或多个语句，多个语句之间用花括号包裹起来。</p><p><strong>在箭头函数中，this 关键字指向的是函数定义时所在的对象，而不是执行时所在的对象。这个特性有助于避免 this 的指向问题，使得代码更加简洁易读。</strong></p><p>需要注意的是，箭头函数不能用作构造函数，也就是不能通过 new 关键字来创建实例。因为箭头函数没有自己的 this，而是继承了外层作用域的 this。如果用 new 来创建实例，就会出现意料之外的结果。</p><h2 id="什么是-webpack-的热更新？它的实现原理是什么？"><a href="#什么是-webpack-的热更新？它的实现原理是什么？" class="headerlink" title="什么是 webpack 的热更新？它的实现原理是什么？"></a>什么是 webpack 的热更新？它的实现原理是什么？</h2><p>webpack 的热更新（Hot Module Replacement，简称 HMR）是一种开发时提高开发效率的技术，可以实现无需刷新页面即可看到代码修改后的效果。在使用 HMR 后，当修改了代码后，webpack 只会重新编译修改的代码，并将新的模块发送到客户端，替换掉旧的模块，从而达到实时更新页面的目的。</p><p>实现 HMR 的关键是在客户端和服务器端之间建立一个 WebSocket 连接，当代码发生变化时，服务器端会将新的模块发送给客户端，客户端接收到新的模块后会用新模块替换旧模块，从而实现实时更新。</p><p>具体来说，webpack HMR 主要分为以下几个步骤：</p><ol><li>启动 webpack-dev-server，配置 HMR 插件</li><li>当代码变化时，webpack-dev-server 会编译出新的模块</li><li>HMR runtime（客户端运行时）会通过 WebSocket 与服务器通信，获取最新的模块</li><li>当 HMR runtime 接收到新模块时，会将新模块加载到浏览器中，并通过模块热替换算法将新模块与旧模块进行比较，只替换有变化的模块部分</li><li>页面更新完成，无需刷新页面即可看到最新的效果。</li></ol><p>总之，HMR 可以大大提高开发效率，同时也能够减少代码变更时的刷新操作，提高开发体验。</p><h2 id="说说常规的前端性能优化手段"><a href="#说说常规的前端性能优化手段" class="headerlink" title="说说常规的前端性能优化手段"></a>说说常规的前端性能优化手段</h2><p>常见的前端性能优化手段有以下几种：</p><ol><li><strong>DNS 优化</strong>：避免浏览器并发数限制，将HTML&#x2F;CSS&#x2F;JS，jpg&#x2F;png，api 接口等不同资源放在不同域名下，从而减少DNS的请求次数；DNS 预解析。</li><li><strong>CDN 回源</strong>：回源指浏览器访问CDN集群上静态文件时，文件缓存过期，直接穿透 CDN 集群而访问源站机器的行为。</li><li><strong>浏览器缓存优化</strong>：IndexDB、cookie、localStorage、sessionstorage。</li><li><strong>HTML5 离线化：</strong>通过选用不同的离线包类型<ul><li>全局离线包：包含公共的资源，可供多个应用共同使用</li><li>私有离线包：只可以被某个应用单独使用</li></ul></li><li><strong>接口优化</strong>：<ul><li>接口合并：减少http请求</li><li>接口上 CDN：把不需要实时更新的接口同步到CDN，如果接口数据更新再重新同步 CDN</li><li>接口域名上 CDN：增强可用性，稳定性</li><li>合理使用缓存：异步接口数据优先使用本地 localstorage 中的缓存数据，通过 md5 判断是否需要数据更新</li></ul></li><li><strong>页面加载策略优化：</strong><ul><li>网络请求优化：减少网络资源的请求和加载耗时<ul><li>预加载</li><li>开启GZIP</li><li>预渲染：可以让浏览器提前加载指定页面的所有资源。</li><li>使用 HTTP&#x2F;2、HTTP&#x2F;3提升资源请求速度</li><li>资源请求合并，减少http请求</li><li>合理使用defer，async</li></ul></li><li>首屏加载优化<ul><li>对页面内容进行分片&#x2F;分屏加载</li><li>懒加载：监听scroll事件；使用IntersectionObserver</li><li>首屏只加载需要的资源，对于不需要的资源不加载。</li><li>客户端离线包方案</li><li>客户端进行预请求和预加载</li></ul></li><li>渲染过程优化：减少用户操作等待时间<ul><li>按需加载</li><li>减少回流和重绘</li><li>减少&#x2F;合并dom操作，减少浏览器的计算损耗</li></ul></li><li>浏览器运算逻辑优化<ul><li>拆解长任务，避免出现长时间计算导致页面卡顿</li><li>提前将计算结果缓存</li></ul></li><li>关键渲染路径优化：关键渲染路径是指浏览器将HTML，CSS，JavaScript转换为屏幕上所呈现的实际像素这期间所经历的一系列步骤。<ul><li>CSS 的 <code>&lt;link&gt;</code> 标签放在 <code>&lt;head&gt;&lt;/head&gt;</code> 之间</li><li><code>&lt;script&gt;</code> 标签放在 <code> &lt;/body&gt;</code> 之前</li></ul></li></ul></li><li><strong>页面静态化（SSR）</strong></li><li><strong>图片优化</strong>：选择合适的图片格式。</li><li><strong>HTML代码优化：</strong><ul><li>精简HTML代码：减少HTML的嵌套；减少DOM节点数；减少无语义代码；删除多余的空格、换行符、缩进等等</li><li>文件放在合适位置：CSS 样式文件链接尽量放在页面头部；JS 放在HTML底部</li></ul></li><li><strong>CSS 代码优化：</strong><ul><li>提升文件加载性能：使用外链的 CSS；尽量避免使用 @import，@import影响css文件的加载速度</li><li>精简 CSS 代码：利用CSS继承减少代码量；避免使用复杂的选择器，层级越少越好</li></ul></li><li><strong>字体文件优化</strong>：<ul><li>使用cdn加载字体文件</li><li>开启gzip压缩字体文件</li><li>通过font-display来调整加载顺序</li><li>字体裁剪，剔除不需要使用到的字体</li><li>内联字体</li></ul></li><li><strong>JS 代码优化</strong>：<ul><li>提升 JS 文件加载性能：JS 文件放在body 底部；合并js文件；合理使用defer和async</li><li>JS 变量和函数优化：尽量使用 id 选择器；尽量避免使用 eval；js 函数尽可能保持整洁；使用节流、防抖函数；使用事件委托</li><li>JS 动画优化：避免添加大量 js 动画；尽量使用 css3 动画；尽量使用 Canvas 动画；使用 <code>requestAnimationFrame</code> 代替 <code>settimeout</code> 和 <code>setinterval</code>。</li></ul></li><li><strong>webpack 打包优化</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day15</title>
      <link href="/2023/03/06/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day15/"/>
      <url>/2023/03/06/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day15/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="什么是-HTML-语义化？为什么要语义化？"><a href="#什么是-HTML-语义化？为什么要语义化？" class="headerlink" title="什么是 HTML 语义化？为什么要语义化？"></a>什么是 HTML 语义化？为什么要语义化？</h2><p>HTML语义化是指在编写HTML文档时，使用恰当的标签和属性，以及正确的结构来描述文档的内容、结构和意义。HTML语义化可以让Web开发人员更好地组织和呈现页面内容，使页面更具有可读性和可访问性，同时也有助于提高SEO优化效果。</p><p>具体来说，HTML语义化可以带来以下几个好处：</p><ol><li>代码可读性：通过语义化的标签和结构，可以更好地描述文档的结构和意义，使代码更加清晰易懂，方便维护和修改。</li><li>改善用户体验：语义化的HTML结构可以提高页面的可读性和可访问性，使页面内容更容易被用户理解和使用，从而提高用户体验。</li><li>提高SEO优化效果：语义化的HTML结构可以提高搜索引擎对页面的理解和评价，使网站更容易被搜索引擎收录和排名，从而提高SEO优化效果。</li><li>更好的跨平台支持：语义化的HTML结构可以使页面更好地适应不同的浏览器和设备，提高页面的跨平台支持性和兼容性。</li><li>更好的可维护性：通过语义化的HTML结构，可以更好地区分页面的内容和样式，使CSS和JavaScript的编写更加简单和直观，从而提高代码的可维护性。</li></ol><p>因此，HTML语义化是Web开发中非常重要的一个概念，它可以帮助开发人员更好地组织和呈现页面内容，提高页面的可读性、可访问性和SEO优化效果，同时也有助于提高代码的可维护性和可扩展性。</p><h2 id="怎么用-JS-实现大型文件上传？要考虑哪些问题？"><a href="#怎么用-JS-实现大型文件上传？要考虑哪些问题？" class="headerlink" title="怎么用 JS 实现大型文件上传？要考虑哪些问题？"></a>怎么用 JS 实现大型文件上传？要考虑哪些问题？</h2><p>在前端实现大型文件上传，需要考虑以下几个问题：</p><p>分片上传：将大文件切割成多个小块进行上传，可以避免一次性上传大文件导致的上传时间过长，网络中断等问题。通常情况下，每个块大小为 1MB 左右。</p><p>断点续传：由于网络等因素，上传过程中可能出现中断，此时需要能够从中断的地方恢复上传。</p><p>并发上传：多个文件同时上传，需要对上传队列进行管理，保证上传速度和顺序。</p><p>上传进度显示：及时显示上传进度，让用户知道上传进度和状态。</p><p>可以通过使用第三方库来实现大型文件上传，比如 Plupload、Resumable.js 等。</p><p>以下是一个使用 Plupload 实现大型文件上传的示例：**(待优化)**</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 Plupload 的 JavaScript 和 CSS 文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;plupload.full.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;plupload.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上传控件的容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;uploader&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn&#x27;t have Flash, Silverlight or HTML5 support.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 初始化上传控件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> uploader = <span class="keyword">new</span> plupload.<span class="title class_">Uploader</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">browse_button</span>: <span class="string">&#x27;uploader&#x27;</span>, <span class="comment">// 上传控件的容器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">url</span>: <span class="string">&#x27;/upload&#x27;</span>, <span class="comment">// 上传文件的 URL</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">multi_selection</span>: <span class="literal">false</span>, <span class="comment">// 是否允许同时上传多个文件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">filters</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">max_file_size</span>: <span class="string">&#x27;100mb&#x27;</span>, <span class="comment">// 最大上传文件大小</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">mime_types</span>: [</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">title</span>: <span class="string">&#x27;Image files&#x27;</span>, <span class="attr">extensions</span>: <span class="string">&#x27;jpg,jpeg,gif,png&#x27;</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">title</span>: <span class="string">&#x27;Zip files&#x27;</span>, <span class="attr">extensions</span>: <span class="string">&#x27;zip,rar&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">init</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 添加文件到上传队列之前触发的事件</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">BeforeUpload</span>: <span class="keyword">function</span> (<span class="params">up, file</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;BeforeUpload:&#x27;</span>, file.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 开始上传文件时触发的事件</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">UploadFile</span>: <span class="keyword">function</span> (<span class="params">up, file</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;UploadFile:&#x27;</span>, file.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 上传进度改变时触发的事件</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">UploadProgress</span>: <span class="keyword">function</span> (<span class="params">up, file</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;UploadProgress:&#x27;</span>, file.<span class="property">percent</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 上传成功时触发的事件</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">FileUploaded</span>: <span class="keyword">function</span> (<span class="params">up, file, info</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;FileUploaded:&#x27;</span>, file.<span class="property">name</span>, info.<span class="property">response</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 上传出错时触发的事件</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Error</span>: <span class="keyword">function</span> (<span class="params">up, err</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error:&#x27;</span>, err.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 初始化上传控件</span></span></span><br><span class="line"><span class="language-javascript">  uploader.<span class="title function_">init</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在后端，需要根据上传控件发送的请求，来实现文件的接收和存储。具体实现方式视具体情况而定，可以使用 SpringMVC、Express.js 等框架来实现。同时，也需要考虑上传文件大小限制、上传速度控制等问题。</p><h2 id="如何提高-webpack-的打包速度？"><a href="#如何提高-webpack-的打包速度？" class="headerlink" title="如何提高 webpack 的打包速度？"></a>如何提高 webpack 的打包速度？</h2><p>以下是一些提高Webpack打包速度的技巧：</p><ol><li>升级Webpack版本：Webpack的新版本通常具有更快的构建速度和更好的性能。</li><li>减少模块解析范围：通过设置resolve.modules、resolve.extensions、resolve.alias等选项，可以让Webpack减少查找和解析模块的范围，从而加快构建速度。</li><li>使用LoaderOptionsPlugin插件：该插件可以将Loader的选项提取到Webpack的配置中，避免在每个Loader中重复设置相同的选项，从而提高构建速度。</li><li>使用HappyPack插件：该插件可以将Webpack的构建任务分解成多个子进程并行执行，从而加快构建速度。</li><li>使用DllPlugin和DllReferencePlugin插件：该插件可以将常用的第三方库预先编译成一个单独的文件，从而避免重复打包，提高构建速度。</li><li>开启缓存：通过设置cache选项或使用cache-loader等插件，可以让Webpack在第二次构建时复用已经处理过的结果，从而加快构建速度。</li><li>压缩代码：使用UglifyJsPlugin等插件可以将代码压缩，从而减少文件大小和加载时间，提高性能。</li><li>移除不必要的插件和Loader：删除不必要的插件和Loader可以减少Webpack的处理时间，从而加快构建速度。</li><li>使用Tree shaking：使用ES6的import和export语句以及Webpack的tree shaking功能可以减少打包后的文件大小，从而提高构建速度和性能。</li><li>使用多个entry和output：使用多个entry和output可以将不同的代码分别打包成多个文件，从而减少每个文件的大小，提高构建速度和性能。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day14</title>
      <link href="/2023/03/06/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day14/"/>
      <url>/2023/03/06/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day14/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="JS-如何顺序执行-10-个异步任务？"><a href="#JS-如何顺序执行-10-个异步任务？" class="headerlink" title="JS 如何顺序执行 10 个异步任务？"></a>JS 如何顺序执行 10 个异步任务？</h2><p>JS 中可以使用 Promise 和 async&#x2F;await 来顺序执行异步任务。</p><p>使用 Promise 可以通过 then() 方法的链式调用来实现顺序执行异步任务，例如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;Async task 1&#x27;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;Async task 2&#x27;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序执行异步任务</span></span><br><span class="line">asyncTask1().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncTask2();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行完异步任务1和异步任务2后的逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 async&#x2F;await 可以将异步任务看作同步代码来执行，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function <span class="built_in">runAsyncTasks</span>() &#123;</span><br><span class="line">  await <span class="built_in">asyncTask1</span>();</span><br><span class="line">  await <span class="built_in">asyncTask2</span>();</span><br><span class="line">  <span class="comment">// 执行完异步任务1和异步任务2后的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">runAsyncTasks</span>();</span><br></pre></td></tr></table></figure><p>在这里，runAsyncTasks() 函数会先执行异步任务 1，等待异步任务 1 完成后再执行异步任务 2。</p><h2 id="React-组件间怎么进行通信？"><a href="#React-组件间怎么进行通信？" class="headerlink" title="React 组件间怎么进行通信？"></a>React 组件间怎么进行通信？</h2><p>React 组件间通信可以通过以下方式实现：</p><ol><li>Props 传递：父组件可以通过 Props 将数据传递给子组件，从而实现数据通信。</li><li>Context：Context 是 React 提供的一种组件间通信的机制，可以通过 Context 在组件树中传递数据，避免 Props 层层传递的麻烦。</li><li>Refs：Refs 允许我们直接操作组件实例或者 DOM 元素，从而实现组件间通信。</li><li>自定义事件：可以通过自定义事件的方式实现组件间的通信。在组件中定义一个事件，当需要在其他组件中触发这个事件时，可以通过回调函数的方式实现。</li><li>全局状态管理：使用全局状态管理工具（如 Redux、Mobx）来管理组件状态，从而实现组件间通信。</li></ol><p>需要根据实际场景选择适合的通信方式。</p><h2 id="介绍一下-JS-中-setTimeout-的运行机制？"><a href="#介绍一下-JS-中-setTimeout-的运行机制？" class="headerlink" title="介绍一下 JS 中 setTimeout 的运行机制？"></a>介绍一下 JS 中 setTimeout 的运行机制？</h2><p>setTimeout()函数：用来指定某个函数或某段代码在多少毫秒之后执行。它接受两个参数：第一个参数是需要执行的代码块，第二个参数是代码块的延迟时间（以毫秒为单位）。它返回一个整数，表示定时器timer的编号，可以用来取消该定时器。是一个异步函数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>最后的打印顺序是：1 3 2 无论setTimeout的执行时间是0还是1000，结果都是先输出3后输出2。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>一个先进先出的队列，它里面存放着各种事件和任务。 所有任务可以分成两种，一种是同步任务，另一种是异步任务。</p><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p><ol><li>输出 如：console.log()</li><li>变量的声明</li><li>同步函数：如果在函数返回的时候，调用者就能够拿到预期的返回值或者看到预期的效果，那么这个函数就是同步的。</li></ol><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><ol><li>setTimeout和setInterval</li><li>DOM事件</li><li>Promise</li><li>process.nextTick</li><li>fs.readFile</li><li>http.get</li><li>异步函数：如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li></ol><h3 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h3><p>异步任务要挂起，先执行同步任务，同步任务执行完毕才会响应异步任务。</p><h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><p>由于 JS 是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。 为了避免因为某些长时间任务造成的无意义等待，JS 引入了异步的概念，用另一个线程来管理异步任务。</p><p>同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程; 等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如 ajax 请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环;</p><p>定时器也是一种异步任务，通常浏览器都有一个独立的定时器模块，定时器的延迟时间就由定时器模块来管理，当某个定时器到了可执行状态，就会被加入主线程队列。</p><p><strong>setTimeout 注册的函数 fn 会交给浏览器的定时器模块来管理，延迟时间到了就将 fn 加入主进程执行队列，如果队列前面还有没有执行完的代码，则又需要花一点时间等待才能执行到 fn，所以实际的延迟时间会比设置的长;</strong> 如在 fn 之前正好有一个超级大循环，那延迟时间就不是一丁点了。</p><p>setInterval 的实现机制跟 setTimeout 类似，只不过 setInterval 是重复执行的。 对于 setInterval(fn, 100) 容易产生一个误区： 并不是上一次 fn 执行完了之后再过 100ms 才开始执行下一次 fn。 事实上，setInterval 并不管上一次 fn 的执行结果，而是每隔 100ms 就将 fn 放入主线程队列; 而两次 fn 之间具体间隔多久就不一定了，跟 setTimeout 实际延迟时间类似，和 JS 执行情况有关。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day13</title>
      <link href="/2023/03/05/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day13/"/>
      <url>/2023/03/05/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day13/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="CSS-中，有哪些方式可以隐藏页面元素？有什么区别"><a href="#CSS-中，有哪些方式可以隐藏页面元素？有什么区别" class="headerlink" title="CSS 中，有哪些方式可以隐藏页面元素？有什么区别?"></a>CSS 中，有哪些方式可以隐藏页面元素？有什么区别?</h2><p>display:none(元素不可见，不占据空间，无法响应点击事件,会触发重排重绘)</p><p>visibility:hidden(元素不可见，占据页面空间，无法响应点击事件，会触发重绘)</p><p>opacity:0(元素不可见，占据页面空间，可以响应点击事件,会触发重绘)</p><p>设置height、width模型属性为0,有内容还要设置overflow:hidden;(元素不可见，不占据页面空间，无法响应点击事件)</p><p>position:absolute(脱标定位到页面外,元素不可见，不影响页面布局)</p><p>clip-path(元素不可见，占据页面空间，无法响应点击事件)</p><h2 id="什么是-JS-对象的可枚举性（enumerable）？"><a href="#什么是-JS-对象的可枚举性（enumerable）？" class="headerlink" title="什么是 JS 对象的可枚举性（enumerable）？"></a>什么是 JS 对象的可枚举性（enumerable）？</h2><h4 id="什么是-JS-对象的可枚举性"><a href="#什么是-JS-对象的可枚举性" class="headerlink" title="什么是 JS 对象的可枚举性"></a>什么是 JS 对象的可枚举性</h4><p>对象的可枚举型是指：</p><p>对象中某些属性是否可以被 for…in 循环或者 Object.keys()函数枚举到，如果一个属性是可枚举的，则会出现在枚举过程中，反之则不会。</p><p>每个属性都有一个名字和一个属性描述符，属性描述符里面包括了该属性的许多特性，如可枚举性、可写性、可配置性和值等。</p><p>默认情况下，使用字面量或Object()构造函数创建的对象的所有属性都是可枚举的，可以使用Object.defineProperty或Object.defineProperties()来设置enumerable特性为false，设置其不可枚举</p><p>tip：</p><p>Object.keys()作用：用于返回一个 <strong>给定对象其自身可枚举的属性</strong> 的数组，该方法接收一个对象作为参数<strong>，返回该对象中所有可枚举属性的名称组成的一个数组</strong>，该数组中的的属性名称按照对象属性定义顺序一致，如果该对象里面的属性没有一个是可枚举性的，则返回空数组。</p><p>Object.defineProperty()作用：<strong>用来定义一个新的属性或者修改原有的属性</strong></p><p>Object.defineProperties()作用：<strong>用来定义或修改多个属性</strong></p><p>这两种都是可以自定义属性的行为，例如定义或修改属性是否可写、可枚举、可配置等；</p><p>它们接收三个参数：1、obj对象；2、prop：要定义或修改的属性名称；3、descriptor：要定义或修改的属性描述符</p><p>descriptor的属性描述符包括的特性有：</p><ol><li>value：属性的值，默认为undefined</li><li>writable：属性是否可写，默认为false</li><li>enumerable：属性是否可枚举，默认为false</li><li>configurable：属性是否可配置，默认为false</li><li>get：获取属性值的方法</li><li>set：设置属性值的方法</li></ol><h2 id="Vue-中-computed-和-watch-区别？分别适用于什么场景？"><a href="#Vue-中-computed-和-watch-区别？分别适用于什么场景？" class="headerlink" title="Vue 中 computed 和 watch 区别？分别适用于什么场景？"></a>Vue 中 computed 和 watch 区别？分别适用于什么场景？</h2><p>Vue 中的 <code>computed</code> 和 <code>watch</code> 是两种用于响应式数据更新的方法。</p><p><code>computed</code> 是计算属性，它会根据响应式数据的变化自动计算出新的值，并缓存结果，只有在计算属性所依赖的响应式数据发生改变时才会重新计算。<code>computed</code> 适用于需要根据响应式数据计算得出结果的场景，例如根据商品的数量和单价计算商品的总价，或者根据选中的过滤条件过滤出数据列表。</p><p><code>watch</code> 是侦听器，它可以监听指定的响应式数据的变化，并在数据发生改变时执行指定的回调函数。<code>watch</code> 适用于需要执行一些异步或复杂操作的场景，例如监听表单输入框的变化并发送 Ajax 请求，或者监听路由变化并根据路由参数切换页面。</p><p>总的来说，<code>computed</code> 适用于计算数据的场景，而 <code>watch</code> 适用于需要执行异步或复杂操作的场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day12</title>
      <link href="/2023/03/04/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day12/"/>
      <url>/2023/03/04/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day12/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="JS-脚本延迟加载的方式有哪些？"><a href="#JS-脚本延迟加载的方式有哪些？" class="headerlink" title="JS 脚本延迟加载的方式有哪些？"></a>JS 脚本延迟加载的方式有哪些？</h2><p>JS 脚本的延迟加载主要有以下几种方式：</p><ul><li><p>async 属性：该属性可以使脚本异步加载，即在页面加载过程中不会阻塞页面的渲染和其他资源的加载。但是，异步执行的脚本不能保证执行顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>defer 属性：该属性也可以使脚本异步加载，但是会在 DOMContentLoaded 事件之前执行，也就是在页面加载完成之后执行，可以保证脚本之间的执行顺序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;test.js&quot;</span> defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态添加 script 标签：可以在页面加载完成后，通过 JavaScript 动态添加 script 标签，实现延迟加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;test.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure></li><li><p>使用 Intersectionobserver API：可以在元素进入视窗时再加载脚本，实现延迟加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="keyword">function</span> (<span class="params">entries</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (entries[<span class="number">0</span>].<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="property">src</span> = <span class="string">&#x27;test.js&#x27;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">threshold</span>: <span class="number">0.5</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#target&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure></li><li><p>setTimeout也可以实现延迟加载，但它并不是一种专门用来实现脚本延迟加载的方式，它更适用于实现定时任务，原理和Intersectionobserver API相似，并不推荐定时器实现延迟加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li><li><p>setTimeout 的时间不能准确控制，如果时间设置过长，会延迟页面的加载速度；如果时间设置过短，可能会在页面还没有完全加载完成时执行脚本，导致错误。</p></li><li><p>无法保证脚本的执行顺序，如果多个脚本使用 setTimeout 加载，可能会导致执行顺序混乱。</p></li></ul><p>注意：async 和 defer 属性只适用于外部脚本，不适用于内联脚本。</p><h2 id="什么是点击穿透，怎么解决？"><a href="#什么是点击穿透，怎么解决？" class="headerlink" title="什么是点击穿透，怎么解决？"></a>什么是点击穿透，怎么解决？</h2><p>点击穿透是指在某些场景下，用户在快速点击页面元素时，由于某些原因（例如网络延迟），在前一个元素上的点击事件还没有完成时，下一个元素的点击事件就已经触发了，导致用户感觉到页面点击无效或者出现异常。</p><p>解决点击穿透的方法有以下几种：</p><ol><li>使用 debounce 或 throttle 函数。这两种函数可以控制函数的执行频率，减少短时间内函数的执行次数，从而减少点击穿透的可能性。</li><li>使用 CSS pointer-events 属性。将当前元素的 pointer-events 属性设为 none，可以禁用当前元素的鼠标事件，从而避免在事件处理函数执行过程中发生点击穿透。</li><li>使用 touch 事件代替 click 事件。在移动设备上，click 事件有300ms的延迟，可能会导致点击穿透。使用 touchstart、touchend 等 touch 事件可以避免这个问题。</li><li>在 click 事件中使用 preventDefault 函数。在 click 事件的处理函数中调用 preventDefault 函数，可以阻止默认的事件行为，从而避免点击穿透。但是这种方法有可能会影响到一些用户习惯，因此需要慎用。</li></ol><p>React为函数组件提供了一些React Hooks，来让函数组件也能拥有类组件的一些特性。</p><h2 id="你常用的-React-Hooks-有哪些"><a href="#你常用的-React-Hooks-有哪些" class="headerlink" title="你常用的 React Hooks 有哪些?"></a>你常用的 React Hooks 有哪些?</h2><h3 id="常用Hooks"><a href="#常用Hooks" class="headerlink" title="常用Hooks"></a>常用Hooks</h3><ul><li><p>useState 在函数中使用state</p></li><li><p>useEffect 用于在函数组件中使用生命周期</p></li><li><p>useContext 不使用组件嵌套就可以订阅 <code>React</code> 的 <code>Context</code></p></li><li><p>useRef 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（<code>initialValue</code>）。返回的 ref 对象在组件的整个生命周期内保持不变。</p></li><li><p>useMemo 返回一个<code>memoized</code>值。，它仅会在某个依赖项改变时才重新计算，有助于避免在每次渲染时都进行高开销的计算。</p></li><li><p>useCallback 返回一个<code>memoized</code>回调函数。把内联回调函数及依赖项数组作为参数传入 <code>useCallback</code>，它将返回该回调函数的 <code>memoized</code> 版本，该回调函数仅在某个依赖项改变时才会更新。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ul><h3 id="部分用法示例"><a href="#部分用法示例" class="headerlink" title="部分用法示例"></a>部分用法示例</h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>首先看他在<code>type.d.ts</code>中的原型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike the class component setState, the updates are not allowed to be partial</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetStateAction</span>&lt;S&gt; = S | (<span class="function">(<span class="params">prevState: S</span>) =&gt;</span> S);</span><br><span class="line"><span class="comment">// this technically does accept a second argument, but it&#x27;s already under a deprecation warning</span></span><br><span class="line"><span class="comment">// and it&#x27;s not even released so probably better to not define it.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dispatch</span>&lt;A&gt; = <span class="function">(<span class="params">value: A</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a stateful value, and a function to update it.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 16.8.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> https://reactjs.org/docs/hooks-reference.html#usestate</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">useState&lt;S&gt;(<span class="attr">initialState</span>: S | (<span class="function">() =&gt;</span> S)): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">SetStateAction</span>&lt;S&gt;&gt;];</span><br></pre></td></tr></table></figure><p>可以推测出他的用法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [var, setVar] = useState(initValue);</span><br></pre></td></tr></table></figure><p>其中var为变量名，setVar为设置var的回调函数，修改var的值都需要通过该回调函数。</p><p>initValue为var的初始值。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DemoComponent</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [time, setTime] = <span class="title function_">useState</span>([<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>()]);</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;time&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fri Mar 03 2023 19:02:05 GMT+0800 (China Standard Time)</span><br></pre></td></tr></table></figure><h5 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h5><p>还是看他的原型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> callbacks are _only_ allowed to return either void, or a destructor.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EffectCallback</span> = <span class="function">() =&gt;</span> (<span class="built_in">void</span> | <span class="title class_">Destructor</span>);</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DependencyList</span> = <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">unknown</span>&gt;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Accepts a function that contains imperative, possibly effectful code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> effect Imperative function that can return a cleanup function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deps If present, effect will only activate if the values in the list change.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 16.8.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> https://reactjs.org/docs/hooks-reference.html#useeffect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useEffect</span>(<span class="params">effect: EffectCallback, deps?: DependencyList</span>): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DemoComponent</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unMounted&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count++&#x27;</span>);</span><br><span class="line">&#125;, [count]);</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Count &#123;count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中以下代码可以被用作onMount和unMount生命周期函数</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onMount&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unMounte&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,[])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day11</title>
      <link href="/2023/03/01/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day11/"/>
      <url>/2023/03/01/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day11/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="前端有哪些实现跨页面通信的方法？"><a href="#前端有哪些实现跨页面通信的方法？" class="headerlink" title="前端有哪些实现跨页面通信的方法？"></a>前端有哪些实现跨页面通信的方法？</h2><p>前端有以下几种实现跨页面通信的方法：</p><ol><li>Cookie：通过在页面间共享 Cookie 实现简单的跨页面通信，但是 Cookie 大小有限制，不能存储过多的数据。</li><li>localStorage 和 sessionStorage：HTML5 提供了本地存储的能力，可以通过 localStorage 或 sessionStorage 实现页面间数据共享，相比 Cookie 更加方便，但是也有大小限制。</li><li>BroadcastChannel API：这是一个 HTML5 新增的 API，允许多个页面间通信，可以广播消息或向特定页面发送消息。</li><li>SharedWorker：SharedWorker 是一种特殊类型的 Web Worker，可以在多个页面间共享数据，可以通过 postMessage API 实现消息传递。</li><li>postMessage API：这是 HTML5 提供的一种消息传递机制，可以在不同窗口或 iframe 间传递消息，可以用来实现跨域通信。</li><li>WebSocket：WebSocket 是一种持久化的协议，可以在浏览器和服务器之间实现双向通信，也可以在不同页面之间实现通信。</li></ol><p>以上这些方法都有其适用的场景和限制条件，需要根据具体情况进行选择和使用。</p><h2 id="TypeScript-的内置数据类型有哪些？"><a href="#TypeScript-的内置数据类型有哪些？" class="headerlink" title="TypeScript 的内置数据类型有哪些？"></a>TypeScript 的内置数据类型有哪些？</h2><p>TypeScript 的内置数据类型包括：</p><ol><li>boolean：布尔类型，true 或 false。</li><li>number：数值类型，包括整数和浮点数。</li><li>string：字符串类型，表示文本。</li><li>Array：数组类型，可以存储多个相同类型的值。</li><li>Tuple：元组类型，可以存储多个不同类型的值，每个值的类型可以自定义。</li><li>Enum：枚举类型，用于定义一些具有特定含义的常量。</li><li>any：任意类型，表示不确定的数据类型。</li><li>void：空类型，表示没有返回值。</li><li>null 和 undefined：表示 null 和 undefined 值。</li><li>never：表示永远不会返回的类型。</li></ol><h2 id="什么是虚拟-DOM？使用虚拟-DOM-一定更快吗？"><a href="#什么是虚拟-DOM？使用虚拟-DOM-一定更快吗？" class="headerlink" title="什么是虚拟 DOM？使用虚拟 DOM 一定更快吗？"></a>什么是虚拟 DOM？使用虚拟 DOM 一定更快吗？</h2><p>虚拟 DOM（Virtual DOM）是一种将浏览器 DOM 抽象为 JavaScript 对象的技术，用于提高 DOM 操作的效率和性能。虚拟 DOM 可以在渲染前对组件的变化进行计算，减少 DOM 操作的次数，从而提高渲染性能。</p><p>使用虚拟 DOM 可以提高性能，但并不是一定更快。虚拟 DOM 需要进行额外的计算和比较操作，而这些操作也会消耗一定的时间和性能。因此，虚拟 DOM 适用于大规模、高度动态的页面，而在简单的静态页面中使用虚拟 DOM 并不能提高性能。此外，虚拟 DOM 还可以提高开发效率，使代码更易于维护和调试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day10</title>
      <link href="/2023/03/01/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day10/"/>
      <url>/2023/03/01/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day10/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="怎么用-CSS-实现一个宽高自适应的正方形？"><a href="#怎么用-CSS-实现一个宽高自适应的正方形？" class="headerlink" title="怎么用 CSS 实现一个宽高自适应的正方形？"></a>怎么用 CSS 实现一个宽高自适应的正方形？</h2><p><strong>方法1、CSS3 vw单位</strong> CSS3 中新增了一组相对于可视区域百分比的长度单位 vw, vh, vmin, vmax。其中 vw 是相对于视口宽度百分比的单位，1vw &#x3D; 1% viewport width， vh 是相对于视口高度百分比的单位，1vh &#x3D; 1% viewport height；vmin 是相对当前视口宽高中 较小 的一个的百分比单位，同理 vmax 是相对当前视口宽高中 较大 的一个的百分比单位。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span>&#123;<span class="attribute">width</span>: <span class="number">100vw</span>;<span class="attribute">height</span>: <span class="number">100vw</span>;<span class="attribute">background</span>: <span class="number">#F2DEDE</span>;&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：简洁方便 缺点：浏览器兼容不好</p><p><strong>方法2、设置垂直方向的padding撑开容器</strong></p><p>在 CSS 盒模型中，margin, padding的百分比数值是相对 <strong>父元素的宽度</strong>计算的。只需将元素垂直方向的一个 padding 值设定为与 width 相同的百分比就可以制作出自适应正方形</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">     <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding-bottom</span>: <span class="number">100%</span>;<span class="comment">/* padding百分比相对父元素宽度计算 */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">0</span>;//避免被内容撑开多余的高度</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>    </span><br></pre></td></tr></table></figure><p>padding百分比+height设置0； 这种方案简洁明了，且兼容性好；通常会给父元素设置固定的高度，子元素设置width百分比布局，通过padding是基于父元素宽度前提下，进行适配</p><p><strong>方法3、利用伪元素的 margin(padding)-top 撑开容器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>:hidden; </span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#F2DEDE</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于容器与伪元素在垂直方向发生了外边距折叠，所以我们想象中的撑开父元素高度并没有出现。而应对的方法是在父元素上触发 BFC：overflow:hidden;</p><p>若使用垂直方向上的 padding 撑开父元素，则不需要触发 BFC，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#F2DEDE</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-top</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> 当元素内部添加内容时高度出现溢出，可以将内容放到独立的内容块中，利用绝对定位消除空间占用，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#F2DEDE</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding-top</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="什么是防抖和节流？如何用-JS-编码实现？"><a href="#什么是防抖和节流？如何用-JS-编码实现？" class="headerlink" title="什么是防抖和节流？如何用 JS 编码实现？"></a>什么是防抖和节流？如何用 JS 编码实现？</h2><p>防抖和节流都是一种优化技术，用来降低函数调用的频率，提高性能。</p><p>防抖（Debounce）：在连续触发某个事件时，只有当一定时间内没有再次触发事件，才会执行事件处理函数。比如说，我们需要监听用户输入框中的文字，只有用户停止输入一段时间，才去发送请求获取数据。</p><p>节流（Throttle）：在一段时间内只执行一次函数，无论事件被触发多少次。比如说，当我们需要监听用户滚动页面时，我们可以在用户滚动时，每隔一定时间就执行一次滚动事件。</p><p>下面是防抖和节流的实现代码：</p><p>防抖实现：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span><span class="params">(func, delay)</span> &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span> &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>搜索框，文本编辑器的实时保存</strong></p><p>节流实现：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span><span class="params">(func, delay)</span> &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速点击，鼠标滑动，下拉加载，scroll事件</strong></p><p>其中 func 是需要进行防抖或节流处理的函数，delay 是事件执行的最小时间间隔。在防抖中，只有当事件触发后 delay 时间内没有再次触发事件，才会执行一次 func 函数；在节流中，每隔 delay 时间执行一次 func 函数。</p><p>需要注意的是，在实际使用时，防抖和节流的处理函数应该在需要进行防抖或节流的事件上进行绑定，而不是在函数内部进行处理。</p><h2 id="什么是-ES6-中的-Promise？它的使用场景有哪些？"><a href="#什么是-ES6-中的-Promise？它的使用场景有哪些？" class="headerlink" title="什么是 ES6 中的 Promise？它的使用场景有哪些？"></a>什么是 ES6 中的 Promise？它的使用场景有哪些？</h2><p>ES6 中的 Promise 是一种处理异步操作的方式，它是一个对象，用于表示一个异步操作的最终完成或失败及其结果值的表示。Promise 对象有三种状态：pending（等待中）、fulfilled（已完成）和 rejected（已失败）。</p><p>Promise 有以下几个优点：</p><ol><li>可以避免回调地狱：将回调函数转换成了链式调用，代码可读性更好。</li><li>可以支持多个并发请求：Promise.all() 可以让多个 Promise 并行执行，提高了执行效率。</li><li>可以在异步代码中捕获错误：Promise.catch() 可以捕获异步代码中的错误。</li></ol><p>Promise 的使用场景包括：</p><ol><li>处理异步操作：比如 Ajax 请求、文件读取等。</li><li>优化回调函数：将回调函数转换成 Promise 链，提高代码可读性。</li><li>实现并发请求：Promise.all() 可以让多个请求并行执行。</li><li>解决回调地狱：将嵌套的回调函数转换成链式调用，提高代码可读性。</li></ol><p>以下是使用 JS 编码实现 Promise 的例子</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 定义一个 <span class="built_in">Promise</span></span><br><span class="line">const promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> 异步操作</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;失败&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 处理 <span class="built_in">Promise</span> 的结果</span><br><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span> =&gt;</span> &#123;</span><br><span class="line">  console.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day9</title>
      <link href="/2023/02/28/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day9/"/>
      <url>/2023/02/28/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day9/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="用-CSS-和-JS-来实现动画分别有哪些优缺点？"><a href="#用-CSS-和-JS-来实现动画分别有哪些优缺点？" class="headerlink" title="用 CSS 和 JS 来实现动画分别有哪些优缺点？"></a>用 CSS 和 JS 来实现动画分别有哪些优缺点？</h2><p>用 CSS 和 JS 来实现动画各有其优缺点，具体如下：</p><p>使用 CSS 实现动画的优缺点：</p><p>优点：</p><ol><li><strong>硬件加速</strong>：CSS 动画会使用浏览器的 GPU 来进行硬件加速，能够更加流畅和高效地运行。</li><li><strong>简单易用</strong>：CSS 动画通常只需要几行代码就能实现基本的动画效果，不需要使用 JavaScript 来控制动画。</li><li><strong>低资源占用</strong>：CSS 动画通常比 JavaScript 动画使用更少的 CPU 和内存资源，因此更适合用于简单的动画效果。</li></ol><p>缺点：</p><ol><li><strong>限制较大</strong>：CSS 动画在实现复杂的动画效果时，受到限制较大，不能像 JavaScript 动画那样自由控制动画的速度、方向等。</li><li><strong>兼容性问题</strong>：由于不同浏览器对 CSS 动画支持程度不同，因此在实现时需要考虑浏览器兼容性问题。</li><li><strong>可维护性差</strong>：当动画效果较为复杂时，使用 CSS 实现的代码会变得冗长和难以维护，因此需要进行代码优化和结构设计。</li></ol><p>使用 JavaScript 实现动画的优缺点：</p><p>优点：</p><ol><li><strong>自由控制</strong>：JavaScript 动画能够更加自由地控制动画的速度、方向等，可以实现更加复杂的动画效果。</li><li><strong>兼容性好</strong>：由于 JavaScript 是浏览器通用的语言，因此在实现动画效果时，能够更好地兼容不同的浏览器。</li><li><strong>可维护性强</strong>：使用 JavaScript 实现动画时，代码结构更加灵活，能够更好地维护和扩展。</li></ol><p>缺点：</p><ol><li><strong>资源占用高</strong>：JavaScript 动画通常需要更多的 CPU 和内存资源，因此在实现动画效果时需要考虑系统资源的消耗问题。</li><li><strong>性能问题</strong>：JavaScript 动画性能受 JavaScript 引擎的影响，而不是浏览器引擎，因此需要对代码进行优化以提高动画性能。</li><li><strong>复杂度高</strong>：JavaScript 动画的实现复杂度通常比 CSS 动画高，因此需要对动画效果进行设计和规划。</li></ol><h2 id="JS-中怎么阻止事件冒泡和事件默认行为？"><a href="#JS-中怎么阻止事件冒泡和事件默认行为？" class="headerlink" title="JS 中怎么阻止事件冒泡和事件默认行为？"></a>JS 中怎么阻止事件冒泡和事件默认行为？</h2><p>在 JavaScript 中，可以通过以下方式阻止事件的冒泡和默认行为：</p><p><strong>阻止事件冒泡：</strong> 事件冒泡是指当一个子元素触发了某个事件后，事件会一直冒泡到它的父元素，直到到达文档根节点。为了阻止事件冒泡，可以使用事件对象的 stopPropagation() 方法。例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.get<span class="constructor">ElementById(<span class="string">&quot;child&quot;</span>)</span>.add<span class="constructor">EventListener(<span class="string">&quot;click&quot;</span>, <span class="params">function</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">  event.stop<span class="constructor">Propagation()</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码中，当子元素被点击时，事件不会继续冒泡到父元素。</p><p><strong>阻止事件默认行为：</strong></p><p>事件的默认行为是指事件发生时，浏览器会默认执行的一些操作，例如提交表单、打开链接等。为了阻止事件的默认行为，可以使用事件对象的 preventDefault() 方法。例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.get<span class="constructor">ElementById(<span class="string">&quot;link&quot;</span>)</span>.add<span class="constructor">EventListener(<span class="string">&quot;click&quot;</span>, <span class="params">function</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 阻止链接的默认跳转行为</span></span><br><span class="line">  event.prevent<span class="constructor">Default()</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码中，当链接被点击时，链接不会跳转到指定的地址。</p><p>需要注意的是，阻止事件的冒泡和默认行为可能会影响用户体验，因此需要谨慎使用。在一些场景下，可以使用阻止事件传播的方式来实现事件委托、事件代理等功能。</p><p>Webpack 是一个开源的前端打包工具，它主要用于将多个 JavaScript 文件打包成一个或多个文件，以便在浏览器中加载。Webpack 的核心功能是对模块进行打包，并支持多种资源的加载和打包，如 JavaScript、CSS、图片、字体等。</p><h2 id="什么是-webpack？它有什么作用？"><a href="#什么是-webpack？它有什么作用？" class="headerlink" title="什么是 webpack？它有什么作用？"></a>什么是 webpack？它有什么作用？</h2><p>Webpack 的主要作用包括：</p><ol><li><strong>模块化</strong>：Webpack 支持各种模块化规范，包括 ES6、CommonJS、AMD 等，可以将应用程序拆分为多个模块，方便管理和维护。</li><li><strong>资源加载</strong>：Webpack 可以处理各种类型的文件，包括 JavaScript、CSS、图片、字体等，可以将这些文件作为模块进行加载和打包。</li><li><strong>代码压缩</strong>：Webpack 可以对代码进行压缩和混淆，减小文件体积，提高页面加载速度。</li><li><strong>代码分割</strong>：Webpack 可以将应用程序拆分成多个 chunk，从而实现按需加载，减小首屏加载时间。</li><li><strong>模块热替换</strong>：Webpack 支持模块热替换，可以在开发过程中快速预览应用程序的变化，提高开发效率。</li><li><strong>优化打包速度</strong>：Webpack 可以使用多线程打包、缓存等技术，优化打包速度。</li></ol><p>需要注意的是，Webpack 本身只是一个打包工具，对于项目的构建和管理，通常需要结合其他工具和插件一起使用，如 Babel、ESLint、PostCSS、Vue Loader 等。同时，Webpack 的配置也比较复杂，需要一定的学习成本。但是一旦熟练掌握，Webpack 可以大大提高项目的可维护性和开发效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day8</title>
      <link href="/2023/02/27/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day8/"/>
      <url>/2023/02/27/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day8/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="JS-中数组是如何在内存中存储的？"><a href="#JS-中数组是如何在内存中存储的？" class="headerlink" title="JS 中数组是如何在内存中存储的？"></a>JS 中数组是如何在内存中存储的？</h2><p>在 JavaScript 中，数组是一种特殊的对象，可以用于存储一组有序的数据。数组在内存中的存储方式与其他对象类似，都是存储在堆中。</p><p>JavaScript 中的数组是一种动态数组，可以自动扩展和收缩。当一个数组需要扩展时，JavaScript 引擎会为其分配更多的内存空间，同时将原有数据拷贝到新的内存空间中。当一个数组需要收缩时，JavaScript 引擎会将其内存空间释放掉。</p><p>在 JavaScript 中，数组的每个元素是通过其索引来访问的。索引是一个整数，用于指定数组中的一个元素。JavaScript 中的数组索引是以 0 开始的，也就是说，第一个元素的索引为 0，第二个元素的索引为 1，以此类推。</p><p>由于 JavaScript 中的数组是动态数组，所以它的索引可以随时改变。因此，当你访问一个数组时，需要确保你正在访问的索引是有效的，否则会导致数组越界的错误。</p><h2 id="Vue-模板是如何编译的？经历了哪些过程？"><a href="#Vue-模板是如何编译的？经历了哪些过程？" class="headerlink" title="Vue 模板是如何编译的？经历了哪些过程？"></a>Vue 模板是如何编译的？经历了哪些过程？</h2><p>Vue 模板在运行时会被编译成渲染函数，最终生成 Virtual DOM，进行页面渲染。</p><p>Vue 模板编译的过程主要分为以下三个步骤：</p><ol><li>解析模板：Vue 会使用正则表达式解析模板字符串，解析出其中的指令、标签、属性等内容。</li><li>生成 AST（抽象语法树）：将解析后的模板字符串转化为抽象语法树，抽象语法树是一个以 JavaScript 对象表示的树形结构，它将模板中的各个节点和属性用 JavaScript 对象的形式表示出来，方便后续对模板进行分析和处理。</li><li>生成渲染函数：将 AST 转化为渲染函数，渲染函数是一个纯 JavaScript 函数，用于将模板转化为 Virtual DOM。</li></ol><p>在模板的编译过程中，还会涉及到动态指令、插槽、组件等特殊情况的处理，不同的编译器实现可能存在一些差异，但大体的编译流程是相似的。</p><p>通过模板的编译，我们可以将模板转化为可被 JavaScript 运行的函数，从而更高效地渲染页面，提高应用的性能。</p><h2 id="JS-中-Map-和-WeakMap-有什么区别？"><a href="#JS-中-Map-和-WeakMap-有什么区别？" class="headerlink" title="JS 中 Map 和 WeakMap 有什么区别？"></a>JS 中 Map 和 WeakMap 有什么区别？</h2><p>在 JavaScript 中，Map 和 WeakMap 都是键值对的集合，但它们有几个重要的区别：</p><ol><li>键类型：Map 对象的键可以是任何类型，包括基本数据类型和对象类型，而 WeakMap 对象的键必须是对象类型。</li><li>垃圾回收：Map 对象中的键和值都会被常规垃圾回收机制回收，而 WeakMap 中的键是弱引用，即在对象被垃圾回收时，WeakMap 中对应的键值对也会被自动删除。这使得 WeakMap 通常用于缓存或元数据，当对象不再被使用时，WeakMap 可以自动清除对应的数据，避免内存泄漏。</li><li>迭代器：Map 对象有内置的迭代器，可以通过 for…of 循环来遍历键值对，而 WeakMap 没有内置的迭代器，因此不能直接遍历键值对。</li></ol><p>综上所述，Map 和 WeakMap 在功能上有所重叠，但应用场景不同。Map 可以存储任何类型的键值对，适用于大部分情况；WeakMap 适用于需要自动清除的缓存和元数据场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day7</title>
      <link href="/2023/02/26/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day7/"/>
      <url>/2023/02/26/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day7/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="CSS3-新增了哪些特性？"><a href="#CSS3-新增了哪些特性？" class="headerlink" title="CSS3 新增了哪些特性？"></a>CSS3 新增了哪些特性？</h2><p>CSS3 是 CSS 的第三个版本，也是最新的 CSS 标准，它包含了 CSS2.1 的所有功能，并且增加了许多丰富的特性：</p><ol><li>替代（IE）盒模型</li><li>选择器：属性选择器、结构伪类选择器、伪元素选择器</li><li>边框与圆角： <code>border-radius</code>、<code>border-image</code>、<code>box-shadow</code></li><li>文本：<code>text-overflow</code>、<code>word-wrap</code>、<code>word-break</code>、<code>text-shadow</code></li><li><code>calc()</code>：<code>cal()</code> 是 CSS3 新增的函数，用于动态计算属性值。</li><li>滤镜（<code>filter</code>）：<code>filter</code> 用于定义元素（一般是<code>&lt;img&gt;</code>）的可视效果（如模糊、饱和度）。</li><li>背景：<code>background-image</code> 、<code>background-size</code>、<code>background-origin</code>、<code>background-clip</code></li><li>渐变（Gradients）：可以实现元素背景中两种或多种颜色之间的渐进过渡效果。</li><li>字体图标：字体图标是一种使用字体文件中的符号来代替图像的技术。与传统的图像图标相比，字体图标具有许多优点，如易于使用、可调整大小、可缩放等。</li><li>过渡（Transition）：用于将元素从一种状态平滑过渡到另一种状态，即实现动画效果。只有在某些特定的事件触发时才能过渡，比如鼠标悬停等。</li><li>动画（Animation）：通过定义关键帧和时间函数来精确控制动画，可以实现比过渡更加自由和复杂的动画效果，且无需通过事件触发。</li><li>多列布局：多列布局是 CSS3 中一种用于分隔文本和内容的布局方式，它可以将一段文本分成多列，从而使页面更加紧凑和易读。</li><li>弹性盒子（Flex Box）：弹性盒子是 CSS3 提供的一种新的布局方式，相比于传统的浮动定位布局更加灵活高效，常用在移动端。</li><li>2D转换：2D 转换是指在二维平面中对元素进行变换，包括平移、缩放、旋转和倾斜，不影响页面布局。</li><li>多媒体查询：CSS3 支持多媒体查询，即根据设备类型来适应不同的屏幕尺寸，从而为用户带来更好的体验。</li><li>3D 转换：3D 转换是指在三维空间中对元素进行变换，包括平移、缩放、旋转、倾斜和透视，不影响页面布局。</li></ol><p>总之，CSS3 是一种强大、灵活、易于维护的样式表语言，它包含了许多新的特性和功能，可以帮助开发者更加高效地创建网页。</p><h2 id="如何使用-JavaScript-来判断用户设备类型？比如判断是-PC-端还是移动端访问？"><a href="#如何使用-JavaScript-来判断用户设备类型？比如判断是-PC-端还是移动端访问？" class="headerlink" title="如何使用 JavaScript 来判断用户设备类型？比如判断是 PC 端还是移动端访问？"></a>如何使用 JavaScript 来判断用户设备类型？比如判断是 PC 端还是移动端访问？</h2><p>可以使用一些特定的 API 来判断用户设备类型，以下是一些常用的方法：</p><ol><li><p><strong>navigator.userAgent</strong>：该属性返回用户代理头的字符串，可以使用正则表达式来判断是否包含移动设备的标识符，例如 “Mobile”、”Android”、”iPhone” 等。如果包含则说明是移动设备，否则是 PC 端。</p></li><li><p>**window.matchMedia()**：该 API 可以根据不同的媒体查询条件来判断用户设备类型，例如屏幕宽度、设备方向等。可以使用 media query 字符串来创建一个 MediaQueryList 对象，然后调用 matches 属性来判断是否匹配。</p></li><li><p><strong>window.innerWidth</strong> 和 <strong>window.innerHeight</strong>：这两个属性返回浏览器窗口的宽度和高度，可以根据窗口大小来判断用户设备类型。通常移动设备的屏幕宽度比较小，因此可以将窗口宽度小于某个值作为判断条件。</p></li><li><p><strong>使用第三方库</strong>：有一些第三方库可以更准确地判断用户设备类型，例如 isMobile、mobile-detect、detect.js 等。这些库通常基于更全面的用户代理头信息和设备特性进行判断，可以提供更精确的结果。使用这些库需要先引入对应的库文件，然后调用相应的方法进行判断。</p></li><li><p><strong>使用特殊标识</strong>：在 URL 参数中添加特殊标识或者在 Cookie 中保存设备类型信息，然后通过解析 URL 参数或者读取 Cookie 中的信息来判断用户设备类型。这种方法需要在用户访问时设置对应的标识或者信息，然后在后续请求中使用。</p></li><li><p><strong>使用 UA 字符串</strong>：每个浏览器都有一个 User-Agent (UA) 字符串，其中包含了浏览器和设备的相关信息。通过解析 UA 字符串，可以判断用户设备类型。但需要注意的是，UA 字符串可以被篡改，因此这种方法并不可靠。</p><h2 id="什么是浏览器的同源策略？为什么要有同源策略？"><a href="#什么是浏览器的同源策略？为什么要有同源策略？" class="headerlink" title="什么是浏览器的同源策略？为什么要有同源策略？"></a>什么是浏览器的同源策略？为什么要有同源策略？</h2></li></ol><p>浏览器同源策略是网景公司出于浏览器安全考虑而制定的策略。同源指的是协议、域名、端口三者均相同，如果三者中存在有不同之处，而称为跨域。跨域请求会被发送到服务器，但是返回的响应会被浏览器拦截。</p><p><strong>同源策略</strong>又分为三种：</p><ol><li>DOM同源策略</li><li>XMLHttpRequest请求同源策略</li><li>Cookie、LocalStorage存储同源策略</li></ol><p>如果不存在同源策略的限制，则会出现XSS、CSRF等Web攻击。比如如果用户通过iframe引入了其他页面，用户在页面中填写了用户名和密码，那么恶意攻击者就可以获取不同源的DOM结构，从而获取用户的信息。又比如用户向网站A发送的请求，网站A向Cookie中添加了用户表示，此时用户访问恶意网站B，执行了恶意脚本，导致网站B向网站A发送Ajax请求并且携带了网站A对应的Cookie，此时网站B就可以从Cookie中解析出用户的信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day6</title>
      <link href="/2023/02/25/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day6/"/>
      <url>/2023/02/25/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day6/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="什么是响应式设计？响应式设计的基本原理是什么？如何进行实现？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何进行实现？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何进行实现？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何进行实现？</h2><p>响应式设计是指通过一些技术手段，使得网站或应用在不同终端设备（如桌面电脑、平板电脑、手机等）上能够自适应地呈现最佳的用户体验。</p><p>响应式设计的基本原理是根据屏幕的尺寸和分辨率等信息，动态调整页面的布局和元素的样式，以便使页面在不同的设备上呈现出最佳的效果。实现响应式设计通常需要使用 HTML、CSS 和 JavaScript 技术，其中 CSS 媒体查询是实现响应式设计的核心技术之一。</p><p>为了实现响应式设计，开发人员需要为不同屏幕尺寸和分辨率等场景提供不同的布局和样式。一种实现方式是使用流体网格布局和百分比尺寸等技术，以便根据设备屏幕的宽度和高度等信息自适应地调整页面的布局和元素的大小。另一种实现方式是使用 CSS 媒体查询，根据设备的屏幕尺寸和分辨率等信息，加载不同的样式文件或应用不同的样式规则，以便实现不同场景下的最佳效果。</p><p>响应式设计的优点包括可以提高用户体验、提高网站访问率和转化率、降低开发成本等。同时，响应式设计也有一些缺点，例如需要在各种设备上进行充分的测试和调试、可能需要加载大量的 CSS 和 JavaScript 文件等。</p><p>总之，响应式设计是一种非常重要的前端开发技术，能够帮助开发人员在不同终端设备上提供最佳的用户体验，提高网站的访问率和转化率，同时也能减少开发成本和维护成本。</p><h2 id="深拷贝和浅拷贝有什么区别？JS-怎么实现深拷贝？"><a href="#深拷贝和浅拷贝有什么区别？JS-怎么实现深拷贝？" class="headerlink" title="深拷贝和浅拷贝有什么区别？JS 怎么实现深拷贝？"></a>深拷贝和浅拷贝有什么区别？JS 怎么实现深拷贝？</h2><p>深拷贝和浅拷贝是复制数据结构的两种不同方式。</p><p>浅拷贝是创建一个新的对象，新对象的一些属性引用原始对象中相同的属性。这意味着在原始对象或新对象上的更改会相互影响。</p><p>深拷贝是创建一个新的对象，并复制原始对象的所有属性，包括嵌套的对象和数组。这意味着在原始对象或新对象上的更改不会相互影响。</p><p>在 JavaScript 中，可以通过以下方式实现深拷贝：</p><p>JSON.parse() 和 JSON.stringify() 方法</p><p>这是实现深拷贝的一种简单方式，但它有一些限制，例如不能复制函数和特殊对象（如 Date）。同时，它不能处理包含循环引用的对象。</p><p>以下是使用 JSON.parse() 和 JSON.stringify() 方法实现深拷贝的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">address</span>: &#123; <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span>, <span class="attr">state</span>: <span class="string">&#x27;NY&#x27;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&#x27;Chicago&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">address</span>.<span class="property">city</span>); <span class="comment">// Output: New York</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">address</span>.<span class="property">city</span>); <span class="comment">// Output: Chicago</span></span><br></pre></td></tr></table></figure><p>递归拷贝对象</p><p>这种方法涉及递归遍历对象，并创建一个新的对象，复制原始对象的属性，并在需要时递归复制嵌套的对象和数组。这种方法可以处理循环引用，并复制函数和特殊对象。</p><p>以下是使用递归拷贝对象实现深拷贝的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        result[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">address</span>: &#123; <span class="attr">city</span>: <span class="string">&#x27;New York&#x27;</span>, <span class="attr">state</span>: <span class="string">&#x27;NY&#x27;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title function_">deepClone</span>(obj);</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&#x27;Chicago&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">address</span>.<span class="property">city</span>); <span class="comment">// Output: New York</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">address</span>.<span class="property">city</span>); <span class="comment">// Output: Chicago</span></span><br></pre></td></tr></table></figure><p>深拷贝的缺点是它可能会更加耗时，因为需要递归遍历整个对象图，复制所有属性和嵌套的对象和数组。而浅拷贝是一种更快的复制方式，因为它只复制了对象的引用。在某些情况下，浅拷贝可能会更有效。</p><h2 id="iframe-标签的作用是什么？有哪些优缺点？"><a href="#iframe-标签的作用是什么？有哪些优缺点？" class="headerlink" title="iframe 标签的作用是什么？有哪些优缺点？"></a>iframe 标签的作用是什么？有哪些优缺点？</h2><p><code>&lt;iframe&gt; 标签是 HTML 中的一个元素，用于在当前 HTML 文档中嵌入另一个 HTML 文档。它可以在一个 HTML 页面中嵌入另一个 HTML 页面或其他类型的文档，比如 PDF 文件或视频文件。</code></p><p><code>&lt;iframe&gt; 标签的主要作用是将一个页面嵌入到另一个页面中。例如，在一个页面中嵌入一个地图或一个视频，或者在一个页面中嵌入一个在线表单，都可以使用 &lt;iframe&gt; 标签。</code></p><p><code>&lt;iframe&gt; 标签的优点包括：</code></p><ul><li>可以让页面嵌入其他网站或文档，从而扩展页面的功能。</li><li>可以使用一个单独的文档来管理页面的内容，从而简化页面的管理。</li><li>可以在一个页面中嵌入多个 ，从而允许多个不同的内容在同一页面中显示。</li></ul><p><code>&lt;iframe&gt; 标签的缺点包括：</code></p><ul><li>可能会影响页面的加载速度和性能，特别是在页面中嵌入大型媒体文件时。</li><li>可能会影响页面的可访问性，因为屏幕阅读器可能无法读取嵌入的内容。</li><li>可能会导致安全风险，因为嵌入的文档可以访问父页面的 JavaScript 对象，从而可能被用于恶意攻击。</li></ul><p>要实现 <code>&lt;iframe&gt;</code> 的效果，可以使用以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 src 属性指定要嵌入的文档的 URL，可以是一个 HTML 页面、一个 PDF 文件或一个视频文件等等。通过设置 width 和 height 属性可以指定<code>&lt;iframe&gt;</code>元素的尺寸。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day5</title>
      <link href="/2023/02/24/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day5/"/>
      <url>/2023/02/24/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day5/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="哪些-CSS-属性可以继承？"><a href="#哪些-CSS-属性可以继承？" class="headerlink" title="哪些 CSS 属性可以继承？"></a>哪些 CSS 属性可以继承？</h2><p>在 CSS 中，并不是所有的属性都可以继承。下面是一些常见的可继承属性：</p><ul><li>font-family</li><li>font-size</li><li>font-weight</li><li>font-style</li><li>color</li><li>letter-spacing</li><li>word-spacing</li><li>line-height</li><li>text-align</li><li>text-indent</li><li>text-transform</li><li>visibility</li></ul><p>这些属性在父元素中设置后，子元素可以继承相同的属性值。但需要注意的是，这些属性只能继承，而不能被子元素覆盖。此外，并不是所有的 HTML 元素都可以继承这些属性，具体需要查看相关属性的文档。</p><h2 id="什么是-BOM-和-DOM？分别列举一些它们的函数"><a href="#什么是-BOM-和-DOM？分别列举一些它们的函数" class="headerlink" title="什么是 BOM 和 DOM？分别列举一些它们的函数"></a>什么是 BOM 和 DOM？分别列举一些它们的函数</h2><p>BOM和DOM都是JavaScript中的概念，但它们具有不同的作用。</p><p>BOM（Browser Object Model）是浏览器对象模型，它提供了一些浏览器窗口和框架的对象，并提供了一些操作这些对象的方法。BOM不是W3C标准，而是由浏览器厂商制定的。</p><p>下面是一些常见的BOM函数：</p><ul><li><code>alert()</code>：在浏览器中显示一个警告框。</li><li><code>confirm()</code>：在浏览器中显示一个确认框，要求用户单击“确定”或“取消”按钮。</li><li><code>prompt()</code>：在浏览器中显示一个提示框，要求用户输入文本。</li><li><code>setTimeout()</code>：用于在指定的时间后执行一段代码。</li><li><code>setInterval()</code>：用于以指定的时间间隔重复执行一段代码。</li></ul><p>DOM（Document Object Model）是文档对象模型，它定义了一种标准的方法来访问和操作HTML或XML文档中的元素和内容。DOM是W3C标准。</p><p>下面是一些常见的DOM函数：</p><ul><li><code>getElementById()</code>：根据元素ID获取元素对象。</li><li><code>getElementsByTagName()</code>：根据标签名获取元素对象数组。</li><li><code>getElementsByClassName()</code>：根据类名获取元素对象数组。</li><li><code>appendChild()</code>：将一个节点添加到指定父节点的子节点列表的末尾。</li><li><code>removeChild()</code>：从指定父节点的子节点列表中删除一个子节点。</li></ul><p>总体来说，BOM主要用于操作浏览器窗口和框架，而DOM主要用于访问和操作HTML或XML文档中的元素和内容。</p><h2 id="说说你对Node-js-的理解？优缺点？应用场景？"><a href="#说说你对Node-js-的理解？优缺点？应用场景？" class="headerlink" title="说说你对Node.js 的理解？优缺点？应用场景？"></a>说说你对Node.js 的理解？优缺点？应用场景？</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许开发者使用 JavaScript 进行服务器端编程。Node.js 拥有事件驱动、非阻塞I&#x2F;O的特性，能够处理高并发的请求，因此它被广泛应用于实时应用、Web应用和API的开发。</p><p>以下是 Node.js 的优缺点：</p><p>优点：</p><ul><li>事件驱动和非阻塞I&#x2F;O的特性能够处理高并发的请求，提高了程序的性能和响应速度；</li><li>使用 JavaScript 进行开发，具有丰富的开源模块和组件，可以大大提高开发效率；</li><li>支持跨平台，可以在 Windows、Linux、MacOS 等多个操作系统上运行；</li><li>可以进行快速原型开发和实时调试。</li></ul><p>缺点：</p><ul><li>Node.js 对于计算密集型的任务和多线程编程支持不够好，适合于 I&#x2F;O 密集型任务；</li><li>因为 Node.js 是基于事件驱动和回调机制的，开发时需要特别注意回调地狱和异步操作的异常处理，否则容易导致代码难以维护。</li></ul><p>Node.js 的应用场景主要包括以下几个方面：</p><ul><li>Web 开发：使用 Node.js 可以快速搭建Web服务器，进行Web开发；</li><li>实时应用：Node.js 支持事件驱动和非阻塞I&#x2F;O，可以用于实时数据传输和消息通信等领域；</li><li>命令行工具：Node.js 可以用于编写命令行工具和脚本；</li><li>微服务：Node.js 支持跨平台和轻量级开发，可以用于编写微服务。</li></ul><p>总之，Node.js 具有很多优点，如高并发处理能力、跨平台性、丰富的开源组件等，但也需要注意其局限性，开发者需要在实践中根据具体需求合理选用技术。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day4</title>
      <link href="/2023/02/24/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day4/"/>
      <url>/2023/02/24/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day4/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="什么是-CSS-盒子模型？"><a href="#什么是-CSS-盒子模型？" class="headerlink" title="什么是 CSS 盒子模型？"></a>什么是 CSS 盒子模型？</h2><p>CSS 盒子模型（CSS box model）指的是用于布局和设计网页的 CSS 样式规范。CSS 盒子模型将每个 HTML 元素表示为一个矩形的盒子，这个盒子包括内容（content）、内边距（padding）、边框（border）和外边距（margin）四个部分。</p><p>具体来说，盒子模型中各个部分的含义如下：</p><ul><li>内容（content）：元素的实际内容，由 width 和 height 属性决定。</li><li>内边距（padding）：内容和边框之间的空间，由 padding 属性决定。</li><li>边框（border）：内容和外边距之间的边框，由 border 属性决定。</li><li>外边距（margin）：盒子边缘和其它元素之间的空间，由 margin 属性决定。</li></ul><p>CSS 盒子模型中，盒子的总大小由这四个部分加起来决定，即 width + padding + border + margin。需要注意的是，CSS 盒子模型有两种，分别是标准盒子模型和怪异盒子模型。</p><ul><li>标准盒子模型中，盒子的大小 &#x3D; width + padding + border + margin</li><li>怪异盒子模型中，盒子的大小 &#x3D; width + margin，因为 width 已经包含了 padding + border</li></ul><h2 id="ES5-中的类和-ES6-中的-class-有什么区别？"><a href="#ES5-中的类和-ES6-中的-class-有什么区别？" class="headerlink" title="ES5 中的类和 ES6 中的 class 有什么区别？"></a>ES5 中的类和 ES6 中的 class 有什么区别？</h2><p>在 ES5 中，我们通常使用构造函数来创建对象和实现继承，而在 ES6 中，引入了类（class）的概念来简化对象创建和继承的过程。下面是 ES5 中类和 ES6 中的 class 的一些区别：</p><ul><li>语法不同：ES5 中使用构造函数来定义类，而 ES6 中使用 class 关键字来定义类。</li><li>继承方式不同：ES5 中使用原型链继承来实现继承，而 ES6 中使用 extends 关键字和 super 函数来实现继承。</li><li>类方法的定义方式不同：ES5 中类方法定义在构造函数的原型对象上，而 ES6 中类方法定义在类的内部。</li><li>类属性的定义方式不同：ES5 中类属性定义在构造函数的原型对象上，而 ES6 中类属性定义在类的内部，并且需要使用 static 关键字来定义静态属性。</li><li>类的调用方式不同：ES5 中需要使用 new 关键字来创建类的实例，而 ES6 中类的调用方式更加简单，只需要像函数一样调用即可。</li></ul><p>需要注意的是，虽然 ES6 中引入了类的概念，但在底层实现上仍然是基于原型链的。因此，理解原型链继承和类的继承是理解 JavaScript 面向对象编程的关键。</p><h2 id="说说你对-TypeScript-的理解？与-JavaScript-的区别？"><a href="#说说你对-TypeScript-的理解？与-JavaScript-的区别？" class="headerlink" title="说说你对 TypeScript 的理解？与 JavaScript 的区别？"></a>说说你对 TypeScript 的理解？与 JavaScript 的区别？</h2><p>TypeScript是一种开源的编程语言，它是JavaScript的一个超集，支持静态类型、类、接口等特性，并且在编译时进行类型检查。TypeScript的设计目标是提高代码的可维护性和可读性，并且可以在大型项目中提供更好的代码组织和重用。</p><p>相比于JavaScript，TypeScript具有以下特点：</p><ul><li>支持类型：TypeScript支持静态类型，在编译时进行类型检查，能够在代码编写阶段发现类型错误，减少运行时错误。</li><li>支持面向对象编程：TypeScript支持类、接口、泛型等面向对象编程特性，可以更好地组织代码和重用代码。</li><li>支持ES6+特性：TypeScript支持ES6+的语法和特性，可以使用最新的语言特性来提高代码质量和可读性。</li><li>更好的编辑器支持：TypeScript 提供了更好的编辑器支持，包括类型检查、代码补全、重构等功能，可以提高开发效率。</li><li>更好的可维护性：TypeScript 的类型系统和面向对象特性可以提高代码的可维护性和可读性，使得代码更加易于维护和扩展。</li></ul><p>总之，TypeScript 可以看作是 JavaScript 的一个超集，它扩展了 JavaScript 的功能，提供了更好的类型检查和面向对象编程特性，可以提高代码的可维护性和可读性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Picgo+Github配置图床</title>
      <link href="/2023/02/23/Picgo-Github%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/02/23/Picgo-Github%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-下载Picgo"><a href="#1-下载Picgo" class="headerlink" title="1.下载Picgo"></a>1.下载Picgo</h3><p>官方下载链接：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>我的是2.3.1版本</p><p><img src="https://cdn.jsdelivr.net/gh/BubuMall/Image/202302231413241.png"></p><h3 id="2-新建Github仓库"><a href="#2-新建Github仓库" class="headerlink" title="2.新建Github仓库"></a>2.新建Github仓库</h3><p>在github新建一个仓库，如Image</p><ol><li>点击右上角头像</li><li>**Settings **→  <strong>Developer settings</strong> →  <strong>Personal access tokens</strong> → <strong>Tokens(classic)</strong> → <strong>Generate new token</strong></li><li>在<strong>Note</strong>输入名称，勾选<strong>repo</strong></li><li>然后生成token复制</li></ol><h3 id="3-配置Picgo"><a href="#3-配置Picgo" class="headerlink" title="3.配置Picgo"></a>3.配置Picgo</h3><p><img src="https://cdn.jsdelivr.net/gh/BubuMall/Image/picgo2.png"></p><p>如图把<strong>token</strong>粘进去，配置参考上图</p><p>设定自定义域名：<code>https://cdn.jsdelivr.net/gh/GitHub /账号名/仓库名 </code><br>（例：<a href="https://cdn.jsdelivr.net/gh/BubuMall/Image%EF%BC%89">https://cdn.jsdelivr.net/gh/BubuMall/Image）</a></p><p>（注：这里使用了jsDelivr进行加速）</p><p>然后记得把Github设为默认的图床</p><h3 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h3><p>然后你想怎么骚就怎么骚吧，每上传一张就commit一次。</p><p>这么聪明的你一定一点就通( ´･ω･)ﾉ(._.&#96;)摸摸头</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day3</title>
      <link href="/2023/02/22/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day3/"/>
      <url>/2023/02/22/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day3/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="ES6-有哪些新特性？"><a href="#ES6-有哪些新特性？" class="headerlink" title="ES6 有哪些新特性？"></a>ES6 有哪些新特性？</h2><p>ES6（ECMAScript 6）是 JavaScript 的第六个版本，也称为 ES2015，引入了很多新特性来增强 JavaScript 语言的能力。下面是 ES6 中一些常见的新特性：</p><ol><li>let 和 const 声明变量</li><li>模板字符串（Template Literals）</li><li>解构赋值（Destructuring）</li><li>箭头函数（Arrow Functions）</li><li>Promise 对象</li><li>函数参数默认值</li><li>对象字面量增强（Object Literal Enhancements）</li><li>类和继承（Classes and Inheritance）</li><li>迭代器（Iterators）</li><li>生成器（Generators）</li><li>模块（Modules）</li><li>Set 和 Map 数据结构</li><li>Symbol 数据类型</li><li>for…of 循环</li><li>let 和 const 块级作用域</li><li>异步函数 async&#x2F;await</li></ol><p>ES6 的新特性增强了 JavaScript 的表现力和编程能力，使得开发者可以更加高效和便捷地编写代码。</p><h2 id="说说-Vue-中的-diff-算法"><a href="#说说-Vue-中的-diff-算法" class="headerlink" title="说说 Vue 中的 diff 算法"></a>说说 Vue 中的 diff 算法</h2><p>Vue 中的 diff 算法是用于更新 Virtual DOM 树，从而实现高效的 DOM 操作。diff 算法会对比新旧两棵 Virtual DOM 树的差异，然后只更新必要的部分，从而减少 DOM 操作的次数。Vue 中的 diff 算法包括以下几个步骤：</p><ol><li><p>新旧节点的比较 diff 算法会首先比较新旧节点是否相同，如果相同，则继续比较子节点；如果不同，则进行下一步操作。</p></li><li><p>对子节点进行比较 对新旧节点的子节点进行比较，具体分为以下四种情况：</p></li><li><ul><li>新节点没有子节点，旧节点有子节点：直接删除旧节点的子节点</li><li>旧节点没有子节点，新节点有子节点：直接添加新节点的子节点</li><li>新旧节点都有子节点：继续比较子节点</li><li>新旧节点都有相同的子节点：对相同的子节点进行递归比较</li></ul></li><li><p>对旧节点多余的子节点进行删除 如果旧节点的子节点比新节点的子节点多，那么对于多余的子节点，直接进行删除。</p></li></ol><p>在 diff 算法中，由于只更新必要的部分，所以可以大大提高 DOM 操作的效率。这也是 Vue 可以实现高效渲染的重要原因之一。</p><h2 id="React-中的路由懒加载是什么？原理是什么？"><a href="#React-中的路由懒加载是什么？原理是什么？" class="headerlink" title="React 中的路由懒加载是什么？原理是什么？"></a>React 中的路由懒加载是什么？原理是什么？</h2><p>React 中的路由懒加载指的是在使用 React Router 进行页面路由时，将页面组件按需加载，而不是一次性加载所有页面组件。这可以提高页面加载速度和性能，尤其在页面中有大量组件的情况下更为明显。</p><p>路由懒加载的原理是基于 ES6 的动态 import 特性，通过在 Webpack 打包时使用 React.lazy() 和 Suspense 进行懒加载，当路由被匹配时才会加载对应的组件，而不是一次性加载所有路由组件，从而减少页面加载时间和网络带宽的消耗。</p><p>下面是一个使用路由懒加载的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Route, Switch &#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const Home = lazy(() =&gt; import(&#x27;./components/Home&#x27;));</span><br><span class="line">const About = lazy(() =&gt; import(&#x27;./components/About&#x27;));</span><br><span class="line">const Contact = lazy(() =&gt; import(&#x27;./components/Contact&#x27;));</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/contact&quot; component=&#123;Contact&#125; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day2</title>
      <link href="/2023/02/22/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day2/"/>
      <url>/2023/02/22/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day2/</url>
      
        <content type="html"><![CDATA[<p><em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id="什么是-HTML5，HTML5-有哪些新特性？"><a href="#什么是-HTML5，HTML5-有哪些新特性？" class="headerlink" title="什么是 HTML5，HTML5 有哪些新特性？"></a>什么是 HTML5，HTML5 有哪些新特性？</h2><p>HTML5是HTML的第五个版本，是用于创建网页和其他web应用程序的标记语言。与之前的HTML版本相比，HTML5引入了许多新特性和改进，包括以下几个方面：</p><ol><li>语义化标签：HTML5引入了很多新的标签，如&lt; header&gt;，&lt; footer&gt;，&lt; nav&gt;，&lt; article&gt;，&lt; section&gt;等，这些标签都是为了更好地表达文档内容的语义而设计的。</li><li>多媒体支持：HTML5支持多媒体内容，包括音频、视频、SVG和Canvas等图形元素，这些都可以直接在网页中嵌入，无需使用第三方插件。</li><li>新的表单控件：HTML5引入了一些新的表单控件，如日期选择器、搜索框、滑块等，这些控件都能够提高用户体验。</li><li>Web存储：HTML5提供了两种新的客户端存储机制：localStorage和sessionStorage，它们可以让Web应用程序在客户端上存储数据，从而提高性能和用户体验。</li><li>Web Workers：HTML5提供了一种新的机制，即Web Workers，它们可以让Web应用程序在后台运行，从而提高性能和响应速度。</li><li>地理位置支持：HTML5提供了一种新的API，即Geolocation API，它可以让Web应用程序获取用户的地理位置信息。</li></ol><p>HTML5的新特性为Web开发提供了更多的功能和工具，让开发者能够更加方便地开发Web应用程序，并提高用户体验</p><h2 id="CSS-中的-1-像素问题是什么？有哪些解决方案？"><a href="#CSS-中的-1-像素问题是什么？有哪些解决方案？" class="headerlink" title="CSS 中的 1 像素问题是什么？有哪些解决方案？"></a>CSS 中的 1 像素问题是什么？有哪些解决方案？</h2><p>CSS 中的 1 像素问题指的是在高分辨率屏幕上显示的 1 像素边框或者细线在实际显示时会比 1 个物理像素更宽或更粗，从而导致边框或者细线看上去比预期的更粗或者更宽，影响页面的美观性和用户体验。</p><p>造成这个问题的原因是由于<strong>高分辨率屏幕的像素密度比传统的屏幕要高，所以在屏幕上显示的一个 CSS 像素对应的物理像素个数也会相应地增多，当使用 CSS 中的 1px 来设置边框或者细线时，实际上渲染出来的线条在屏幕上会被拆分为多个物理像素，从而导致看上去更粗。</strong></p><p>解决这个问题的方法有以下几种：</p><ol><li><p>使用图片代替边框或细线，这种方法能够保证显示效果的一致性，但是需要制作多张图片，增加了页面加载的开销。</p></li><li><p>使用 scale 进行缩放，使用 transform 缩放 0.5 像素大小的边框，以达到渲染 1 像素的效果。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 border-image，border-image 可以实现将一张图片作为边框样式，图片会自动拉伸或者重复以填充边框。这种方法需要制作一张边框的图片，但是可以通过 CSS 控制图片的填充方式和边框样式，比较灵活。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">border.png</span>) <span class="number">1</span> <span class="number">1</span> stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 CSS3 的 box-shadow，可以用 box-shadow 属性来模拟边框。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 viewport，在 head 中添加如下代码可以解决 1px 问题：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript-中如何中止网络请求？"><a href="#JavaScript-中如何中止网络请求？" class="headerlink" title="JavaScript 中如何中止网络请求？"></a>JavaScript 中如何中止网络请求？</h2><p>在 JavaScript 中，我们可以通过 AbortController 和 AbortSignal 来中止网络请求。</p><p>使用 AbortController 创建一个新的 AbortController 对象，然后使用它的 abort() 方法来中止请求。在创建请求时，将 AbortController.signal 分配给请求的 signal 属性，以便在调用 abort() 方法时取消请求。</p><p>以下是一个使用 AbortController 中止 fetch 请求的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123; signal &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Handle the response</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error.<span class="property">name</span> === <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request was cancelled&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request failed:&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// To abort the request, call the following:</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星哥の面试题Day1</title>
      <link href="/2023/02/22/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day1/"/>
      <url>/2023/02/22/%E6%98%9F%E5%93%A5%E3%81%AE%E9%9D%A2%E8%AF%95%E9%A2%98Day1/</url>
      
        <content type="html"><![CDATA[<p>今天还是把之前的面试题给总结一下吧，<em>面试题系列均来自鱼皮的知识星球——<a href="https://t.zsxq.com/0b6WUnJog">编程导航</a></em></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="CSS-选择器有哪些？优先级分别是什么？"><a href="#CSS-选择器有哪些？优先级分别是什么？" class="headerlink" title="CSS 选择器有哪些？优先级分别是什么？"></a>CSS 选择器有哪些？优先级分别是什么？</h3><p>CSS 选择器可以根据不同的属性、标签名、类名、ID 等条件来选择页面中的元素，常用的选择器包括：</p><ol><li>标签选择器：通过标签名选取元素，如 p、h1、div 等。</li><li>类选择器：以 “.” 开头，选取具有相同类名的元素，如 .red、.bold 等。</li><li>ID 选择器：以 “#” 开头，选取具有相同 ID 的元素，如 #header、#content 等。</li><li>属性选择器：根据元素的属性值选取元素，如 [href]、[title]、[src] 等。</li><li>后代选择器：选取元素的后代元素，如 div p 选取所有 div 元素的后代 p 元素。</li><li>相邻兄弟选择器：选取元素的相邻兄弟元素，如 h1 + p 选取紧接在 h1 元素后面的 p 元素。</li><li>通用选择器：选取所有元素，使用 * 表示。</li></ol><p>CSS 选择器的优先级按照如下规则计算：</p><ol><li>标签内部样式（内联样式）具有最高优先级，其次是 ID 选择器，然后是类选择器和属性选择器，最后是标签选择器和通用选择器。</li><li>如果存在多个选择器的优先级相同，那么后面出现的选择器具有更高的优先级。</li><li>!important 声明具有最高优先级。</li></ol><p>使用 CSS 选择器，可以选择页面中的特定元素，并对其应用样式，从而实现对页面布局和样式的控制。</p><h2 id="有哪些常见的-CSS-布局？"><a href="#有哪些常见的-CSS-布局？" class="headerlink" title="有哪些常见的 CSS 布局？"></a>有哪些常见的 CSS 布局？</h2><p>CSS 布局是指在网页上排版并定位元素的方式，常见的 CSS 布局包括：</p><ol><li>盒模型布局：盒模型布局是指通过设置元素的 margin、padding、border 等属性，控制元素在页面中的位置和大小。</li><li>浮动布局：浮动布局是通过设置元素的 float 属性，使元素脱离文档流并向左或向右浮动，从而实现对页面布局的控制。</li><li>定位布局：定位布局是指通过设置元素的 position 属性为 relative、absolute 或 fixed，控制元素在页面上的位置。</li><li>弹性布局：弹性布局是通过设置元素的 display 属性为 flex 或 inline-flex，控制元素在页面中的位置和大小，从而实现响应式布局。</li><li>网格布局：网格布局是通过设置元素的 display 属性为 grid，使用网格线将页面分为若干行和列，控制元素在页面中的位置和大小。</li></ol><p>以上是常见的 CSS 布局，开发者可以根据具体的需求和情况选择合适的布局方式，从而实现对页面布局和样式的控制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 求职 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改主题为ButterFly</title>
      <link href="/2023/02/09/%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98%E4%B8%BAButterFly/"/>
      <url>/2023/02/09/%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98%E4%B8%BAButterFly/</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>​按照butterfly的文档设置，一般都不会出什么问题</p><h2 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h2><p>​我就遇到背景图瞎折腾了一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># The banner image of home page</span><br><span class="line">index_img: &#x27;transparent&#x27;</span><br><span class="line"># Website Background (設置網站背景)</span><br><span class="line"># can set it to color or image (可設置圖片 或者 顔色)</span><br><span class="line"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span><br><span class="line">background: url(/img/nahida.jpg)</span><br><span class="line"># Footer Background</span><br><span class="line">footer_bg: &#x27;transparent&#x27;</span><br></pre></td></tr></table></figure><p>头部，底部弄成透明就行了</p><h2 id="加一个纳西妲看板娘"><a href="#加一个纳西妲看板娘" class="headerlink" title="加一个纳西妲看板娘"></a>加一个纳西妲看板娘</h2><p>​这个倒是费了我挺多时间的，之前博客已经弄过，用hexo-live2d的插件，但这次我想要自己弄一个纳西妲的。</p><p>​在一个B站up主<a href="https://space.bilibili.com/72073139">天才设计学家</a>上找到了合适的。下载下来后就找框架了，又参考了大佬九弓子的可莉看板娘。用了live2d的官方模板，再自己稍稍魔改一下（还是借鉴）。</p><p>于是就有了以下的效果</p><h2 id="页底添加爱心和小破站已运行时间"><a href="#页底添加爱心和小破站已运行时间" class="headerlink" title="页底添加爱心和小破站已运行时间"></a>页底添加爱心和<del>小破站</del>已运行时间</h2><p>我真的是到处参考大佬们的技术博客，人都要麻了</p><p>看板娘我搞了好久，一直不满意再加上拖延</p><p>爱心跟已运行时间借鉴这位<a href="https://cnhuazhu.gitee.io/2021/02/24/Hexo%E9%AD%94%E6%94%B9/Hexo%E9%A1%B5%E8%84%9A%E7%BE%8E%E5%8C%96/">花猪</a>大哥的博客</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态心跳</span></span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    $(<span class="string">&#x27;.copyright&#x27;</span>).<span class="title function_">html</span>(<span class="string">&#x27;©2021 &lt;i class=&quot;fa-fw fas fa-heartbeat card-announcement-animation cc_pointer&quot;&gt;&lt;/i&gt; By 花猪&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="title function_">show_date_time</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//本站运行时间</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show_date_time</span>(<span class="params"></span>)&#123;</span><br><span class="line">$(<span class="string">&#x27;.framework-info&#x27;</span>).<span class="title function_">html</span>(<span class="string">&#x27;本站已运行&lt;span id=&quot;span_dt_dt&quot; style=&quot;color: #fff;&quot;&gt;&lt;/span&gt;&#x27;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="string">&quot;show_date_time()&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="title class_">BirthDay</span>=<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;1/20/2021 0:0:0&quot;</span>);</span><br><span class="line">today=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">timeold=(today.<span class="title function_">getTime</span>()-<span class="title class_">BirthDay</span>.<span class="title function_">getTime</span>());</span><br><span class="line">sectimeold=timeold/<span class="number">1000</span></span><br><span class="line">secondsold=<span class="title class_">Math</span>.<span class="title function_">floor</span>(sectimeold);</span><br><span class="line">msPerDay=<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span></span><br><span class="line">e_daysold=timeold/msPerDay</span><br><span class="line">daysold=<span class="title class_">Math</span>.<span class="title function_">floor</span>(e_daysold);</span><br><span class="line">e_hrsold=(e_daysold-daysold)*<span class="number">24</span>;</span><br><span class="line">hrsold=<span class="title class_">Math</span>.<span class="title function_">floor</span>(e_hrsold);</span><br><span class="line">e_minsold=(e_hrsold-hrsold)*<span class="number">60</span>;</span><br><span class="line">minsold=<span class="title class_">Math</span>.<span class="title function_">floor</span>((e_hrsold-hrsold)*<span class="number">60</span>);</span><br><span class="line">seconds=<span class="title class_">Math</span>.<span class="title function_">floor</span>((e_minsold-minsold)*<span class="number">60</span>);</span><br><span class="line">span_dt_dt.<span class="property">innerHTML</span>=<span class="string">&#x27;&lt;font style=color:#afb4db&gt;&#x27;</span>+daysold+<span class="string">&#x27;&lt;/font&gt; 天 &lt;font style=color:#f391a9&gt;&#x27;</span>+hrsold+<span class="string">&#x27;&lt;/font&gt; 时 &lt;font style=color:#fdb933&gt;&#x27;</span>+minsold+<span class="string">&#x27;&lt;/font&gt; 分 &lt;font style=color:#a3cf62&gt;&#x27;</span>+seconds+<span class="string">&#x27;&lt;/font&gt; 秒&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用了之后效果不显示，原来要引入jq</p><p>在<strong>主题配置文件</strong>下的<strong>inject</strong>引入</p><p><img src="https://cdn.jsdelivr.net/gh/BubuMall/Image/202302231342301.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="添加浏览时间"><a href="#添加浏览时间" class="headerlink" title="添加浏览时间"></a>添加浏览时间</h2><p>如图</p><img src="https://cdn.jsdelivr.net/gh/BubuMall/Image/202302231355949.png" style="zoom:67%;" /><h1 id="摆烂了！魔改太费时间了，看到的想弄参考这个，很简单哦☺！！"><a href="#摆烂了！魔改太费时间了，看到的想弄参考这个，很简单哦☺！！" class="headerlink" title="摆烂了！魔改太费时间了，看到的想弄参考这个，很简单哦☺！！"></a>摆烂了！魔改太费时间了，看到的想弄参考这个，很简单哦☺！！</h1><p><em>因为我没流量再看这些花里胡哨的博客了</em></p><p><a href="https://butterfly.zhheo.com/">直达魔改电梯</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> 纳西妲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/09/hello-world/"/>
      <url>/2023/02/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
